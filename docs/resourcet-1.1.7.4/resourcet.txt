-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Deterministic allocation and freeing of scarce resources.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/resourcet</a>.
@package resourcet
@version 1.1.7.4

module Data.Acquire.Internal

-- | A method for acquiring a scarce resource, providing the means of
--   freeing it when no longer needed. This data type provides
--   <tt>Functor</tt><i><tt>Applicative</tt></i><tt>Monad</tt> instances
--   for composing different resources together. You can allocate these
--   resources using either the <tt>bracket</tt> pattern (via
--   <tt>with</tt>) or using <tt>ResourceT</tt> (via
--   <tt>allocateAcquire</tt>).
--   
--   This concept was originally introduced by Gabriel Gonzalez and
--   described at:
--   <a>http://www.haskellforall.com/2013/06/the-resource-applicative.html</a>.
--   The implementation in this package is slightly different, due to
--   taking a different approach to async exception safety.
--   
--   Since 1.1.0
newtype Acquire a
Acquire :: ((forall b. IO b -> IO b) -> IO (Allocated a)) -> Acquire a
data Allocated a
Allocated :: !a -> !(ReleaseType -> IO ()) -> Allocated a

-- | Allocate the given resource and provide it to the provided function.
--   The resource will be freed as soon as the inner block is exited,
--   whether normally or via an exception. This function is similar in
--   function to <tt>bracket</tt>.
--   
--   Since 1.1.0
with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b

-- | Same as <tt>with</tt>, but uses the <tt>MonadMask</tt> typeclass from
--   exceptions instead of <tt>MonadBaseControl</tt> from exceptions.
--   
--   Since 1.1.3
withEx :: (MonadMask m, MonadIO m) => Acquire a -> (a -> m b) -> m b

-- | Create an <tt>Acquire</tt> value using the given allocate and free
--   functions.
--   
--   Since 1.1.0
mkAcquire :: IO a -> (a -> IO ()) -> Acquire a

-- | The way in which a release is called.
--   
--   Since 1.1.2
data ReleaseType
ReleaseEarly :: ReleaseType
ReleaseNormal :: ReleaseType
ReleaseException :: ReleaseType

-- | Same as <a>mkAcquire</a>, but the cleanup function will be informed of
--   <i>how</i> cleanup was initiated. This allows you to distinguish, for
--   example, between normal and exceptional exits.
--   
--   Since 1.1.2
mkAcquireType :: IO a -> (a -> ReleaseType -> IO ()) -> Acquire a
instance GHC.Enum.Bounded Data.Acquire.Internal.ReleaseType
instance GHC.Enum.Enum Data.Acquire.Internal.ReleaseType
instance GHC.Classes.Ord Data.Acquire.Internal.ReleaseType
instance GHC.Classes.Eq Data.Acquire.Internal.ReleaseType
instance GHC.Read.Read Data.Acquire.Internal.ReleaseType
instance GHC.Show.Show Data.Acquire.Internal.ReleaseType
instance GHC.Base.Functor Data.Acquire.Internal.Acquire
instance GHC.Base.Applicative Data.Acquire.Internal.Acquire
instance GHC.Base.Monad Data.Acquire.Internal.Acquire
instance Control.Monad.IO.Class.MonadIO Data.Acquire.Internal.Acquire
instance Control.Monad.Base.MonadBase GHC.Types.IO Data.Acquire.Internal.Acquire

module Control.Monad.Trans.Resource.Internal

-- | Indicates either an error in the library, or misuse of it (e.g., a
--   <tt>ResourceT</tt>'s state is accessed after being released).
--   
--   Since 0.3.0
data InvalidAccess
InvalidAccess :: String -> InvalidAccess
[functionName] :: InvalidAccess -> String

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack which includes a <tt>ResourceT</tt> can be
--   an instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a
--   <tt>MonadBaseControl IO m</tt> monad, which allows control operations
--   to be lifted. A <tt>MonadResource</tt> does not have this requirement.
--   This means that transformers such as <tt>ContT</tt> can be an instance
--   of <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will
--   need to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class (MonadThrow m, MonadIO m, Applicative m, MonadBase IO m) => MonadResource m

-- | Lift a <tt>ResourceT IO</tt> action into the current <tt>Monad</tt>.
--   
--   Since 0.4.0
liftResourceT :: MonadResource m => ResourceT IO a -> m a

-- | A lookup key for a specific release action. This value is returned by
--   <tt>register</tt> and <tt>allocate</tt>, and is passed to
--   <tt>release</tt>.
--   
--   Since 0.3.0
data ReleaseKey
ReleaseKey :: !(IORef ReleaseMap) -> !Int -> ReleaseKey
data ReleaseMap
ReleaseMap :: !NextKey -> !RefCount -> !(IntMap (ReleaseType -> IO ())) -> ReleaseMap
ReleaseMapClosed :: ReleaseMap

-- | Convenient alias for <tt>ResourceT IO</tt>.
type ResIO a = ResourceT IO a

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <tt>runResourceT</tt>). Actions may be registered via
--   <tt>register</tt>, or resources may be allocated atomically via
--   <tt>allocate</tt>. <tt>allocate</tt> corresponds closely to
--   <tt>bracket</tt>.
--   
--   Releasing may be performed before exit via the <tt>release</tt>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Since 0.3.0
newtype ResourceT m a
ResourceT :: (IORef ReleaseMap -> m a) -> ResourceT m a
[unResourceT] :: ResourceT m a -> IORef ReleaseMap -> m a
stateAlloc :: IORef ReleaseMap -> IO ()
stateCleanup :: ReleaseType -> IORef ReleaseMap -> IO ()

-- | Transform the monad a <tt>ResourceT</tt> lives in. This is most often
--   used to strip or add new transformers to a stack, e.g. to run a
--   <tt>ReaderT</tt>.
--   
--   Note that this function is a slight generalization of <a>hoist</a>.
--   
--   Since 0.3.0
transResourceT :: (m a -> n b) -> ResourceT m a -> ResourceT n b
register' :: IORef ReleaseMap -> IO () -> IO ReleaseKey

-- | Since 1.1.2
registerType :: IORef ReleaseMap -> (ReleaseType -> IO ()) -> IO ReleaseKey
instance Control.Monad.Cont.Class.MonadCont m => Control.Monad.Cont.Class.MonadCont (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.RWS.Class.MonadRWS r w s m => Control.Monad.RWS.Class.MonadRWS r w s (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Reader.Class.MonadReader r m => Control.Monad.Reader.Class.MonadReader r (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.State.Class.MonadState s m => Control.Monad.State.Class.MonadState s (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Writer.Class.MonadWriter w m => Control.Monad.Writer.Class.MonadWriter w (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Catch.MonadThrow m => Control.Monad.Catch.MonadThrow (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Catch.MonadCatch m => Control.Monad.Catch.MonadCatch (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Catch.MonadMask m => Control.Monad.Catch.MonadMask (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance (Control.Monad.Catch.MonadThrow m, Control.Monad.Base.MonadBase GHC.Types.IO m, Control.Monad.IO.Class.MonadIO m, GHC.Base.Applicative m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Morph.MFunctor Control.Monad.Trans.Resource.Internal.ResourceT
instance Control.Monad.Morph.MMonad Control.Monad.Trans.Resource.Internal.ResourceT
instance GHC.Show.Show Control.Monad.Trans.Resource.Internal.InvalidAccess
instance GHC.Exception.Exception Control.Monad.Trans.Resource.Internal.InvalidAccess
instance GHC.Base.Functor m => GHC.Base.Functor (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.Alternative m => GHC.Base.Alternative (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.MonadPlus m => GHC.Base.MonadPlus (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Trans.Class.MonadTrans Control.Monad.Trans.Resource.Internal.ResourceT
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Base.MonadBase b m => Control.Monad.Base.MonadBase b (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Trans.Control.MonadTransControl Control.Monad.Trans.Resource.Internal.ResourceT
instance Control.Monad.Trans.Control.MonadBaseControl b m => Control.Monad.Trans.Control.MonadBaseControl b (Control.Monad.Trans.Resource.Internal.ResourceT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Identity.IdentityT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.List.ListT m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Maybe.MaybeT m)
instance (Control.Monad.Trans.Error.Error e, Control.Monad.Trans.Resource.Internal.MonadResource m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Error.ErrorT e m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Except.ExceptT e m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Reader.ReaderT r m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Cont.ContT r m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.State.Lazy.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Resource.Internal.MonadResource m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Resource.Internal.MonadResource m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.RWS.Lazy.RWST r w s m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Resource.Internal.MonadResource m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.RWS.Strict.RWST r w s m)
instance Control.Monad.Trans.Resource.Internal.MonadResource m => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.State.Strict.StateT s m)
instance (GHC.Base.Monoid w, Control.Monad.Trans.Resource.Internal.MonadResource m) => Control.Monad.Trans.Resource.Internal.MonadResource (Control.Monad.Trans.Writer.Strict.WriterT w m)


-- | Allocate resources which are guaranteed to be released.
--   
--   For more information, see
--   <a>https://www.fpcomplete.com/user/snoyberg/library-documentation/resourcet</a>.
--   
--   One point to note: all register cleanup actions live in the
--   <tt>IO</tt> monad, not the main monad. This allows both more efficient
--   code, and for monads to be transformed.
module Control.Monad.Trans.Resource

-- | The Resource transformer. This transformer keeps track of all
--   registered actions, and calls them upon exit (via
--   <tt>runResourceT</tt>). Actions may be registered via
--   <tt>register</tt>, or resources may be allocated atomically via
--   <tt>allocate</tt>. <tt>allocate</tt> corresponds closely to
--   <tt>bracket</tt>.
--   
--   Releasing may be performed before exit via the <tt>release</tt>
--   function. This is a highly recommended optimization, as it will ensure
--   that scarce resources are freed early. Note that calling
--   <tt>release</tt> will deregister the action, so that a release action
--   will only ever be called once.
--   
--   Since 0.3.0
data ResourceT m a

-- | Convenient alias for <tt>ResourceT IO</tt>.
type ResIO a = ResourceT IO a

-- | A lookup key for a specific release action. This value is returned by
--   <tt>register</tt> and <tt>allocate</tt>, and is passed to
--   <tt>release</tt>.
--   
--   Since 0.3.0
data ReleaseKey

-- | Unwrap a <a>ResourceT</a> transformer, and call all registered release
--   actions.
--   
--   Note that there is some reference counting involved due to
--   <a>resourceForkIO</a>. If multiple threads are sharing the same
--   collection of resources, only the last call to <tt>runResourceT</tt>
--   will deallocate the resources.
--   
--   Since 0.3.0
runResourceT :: MonadBaseControl IO m => ResourceT m a -> m a

-- | Introduce a reference-counting scheme to allow a resource context to
--   be shared by multiple threads. Once the last thread exits, all
--   remaining resources will be released.
--   
--   Note that abuse of this function will greatly delay the deallocation
--   of registered resources. This function should be used with care. A
--   general guideline:
--   
--   If you are allocating a resource that should be shared by multiple
--   threads, and will be held for a long time, you should allocate it at
--   the beginning of a new <tt>ResourceT</tt> block and then call
--   <tt>resourceForkIO</tt> from there.
--   
--   Since 0.3.0
resourceForkIO :: MonadBaseControl IO m => ResourceT m () -> ResourceT m ThreadId

-- | Transform the monad a <tt>ResourceT</tt> lives in. This is most often
--   used to strip or add new transformers to a stack, e.g. to run a
--   <tt>ReaderT</tt>.
--   
--   Note that this function is a slight generalization of <a>hoist</a>.
--   
--   Since 0.3.0
transResourceT :: (m a -> n b) -> ResourceT m a -> ResourceT n b

-- | This function mirrors <tt>join</tt> at the transformer level: it will
--   collapse two levels of <tt>ResourceT</tt> into a single
--   <tt>ResourceT</tt>.
--   
--   Since 0.4.6
joinResourceT :: ResourceT (ResourceT m) a -> ResourceT m a

-- | Perform some allocation, and automatically register a cleanup action.
--   
--   This is almost identical to calling the allocation and then
--   <tt>register</tt>ing the release action, but this properly handles
--   masking of asynchronous exceptions.
--   
--   Since 0.3.0
allocate :: MonadResource m => IO a -> (a -> IO ()) -> m (ReleaseKey, a)

-- | Register some action that will be called precisely once, either when
--   <a>runResourceT</a> is called, or when the <a>ReleaseKey</a> is passed
--   to <a>release</a>.
--   
--   Since 0.3.0
register :: MonadResource m => IO () -> m ReleaseKey

-- | Call a release action early, and deregister it from the list of
--   cleanup actions to be performed.
--   
--   Since 0.3.0
release :: MonadIO m => ReleaseKey -> m ()

-- | Unprotect resource from cleanup actions, this allowes you to send
--   resource into another resourcet process and reregister it there. It
--   returns an release action that should be run in order to clean
--   resource or Nothing in case if resource is already freed.
--   
--   Since 0.4.5
unprotect :: MonadIO m => ReleaseKey -> m (Maybe (IO ()))

-- | Perform asynchronous exception masking.
--   
--   This is more general then <tt>Control.Exception.mask</tt>, yet more
--   efficient than <tt>Control.Exception.Lifted.mask</tt>.
--   
--   Since 0.3.0
resourceMask :: MonadResource m => ((forall a. ResourceT IO a -> ResourceT IO a) -> ResourceT IO b) -> m b

-- | A <tt>Monad</tt> which allows for safe resource allocation. In theory,
--   any monad transformer stack which includes a <tt>ResourceT</tt> can be
--   an instance of <tt>MonadResource</tt>.
--   
--   Note: <tt>runResourceT</tt> has a requirement for a
--   <tt>MonadBaseControl IO m</tt> monad, which allows control operations
--   to be lifted. A <tt>MonadResource</tt> does not have this requirement.
--   This means that transformers such as <tt>ContT</tt> can be an instance
--   of <tt>MonadResource</tt>. However, the <tt>ContT</tt> wrapper will
--   need to be unwrapped before calling <tt>runResourceT</tt>.
--   
--   Since 0.3.0
class (MonadThrow m, MonadIO m, Applicative m, MonadBase IO m) => MonadResource m

-- | Lift a <tt>ResourceT IO</tt> action into the current <tt>Monad</tt>.
--   
--   Since 0.4.0
liftResourceT :: MonadResource m => ResourceT IO a -> m a

-- | A <tt>Monad</tt> which can be used as a base for a <tt>ResourceT</tt>.
--   
--   A <tt>ResourceT</tt> has some restrictions on its base monad:
--   
--   <ul>
--   <li><tt>runResourceT</tt> requires an instance of <tt>MonadBaseControl
--   IO</tt>.</li>
--   <li><tt>MonadResource</tt> requires an instance of
--   <tt>MonadThrow</tt>, <tt>MonadIO</tt>, and <tt>Applicative</tt>.</li>
--   </ul>
--   
--   While any instance of <tt>MonadBaseControl IO</tt> should be an
--   instance of the other classes, this is not guaranteed by the type
--   system (e.g., you may have a transformer in your stack with does not
--   implement <tt>MonadThrow</tt>). Ideally, we would like to simply
--   create an alias for the five type classes listed, but this is not
--   possible with GHC currently.
--   
--   Instead, this typeclass acts as a proxy for the other five. Its only
--   purpose is to make your type signatures shorter.
--   
--   Note that earlier versions of <tt>conduit</tt> had a typeclass
--   <tt>ResourceIO</tt>. This fulfills much the same role.
--   
--   Since 0.3.2
type MonadResourceBase m = (MonadBaseControl IO m, MonadThrow m, MonadBase IO m, MonadIO m, Applicative m)

-- | Indicates either an error in the library, or misuse of it (e.g., a
--   <tt>ResourceT</tt>'s state is accessed after being released).
--   
--   Since 0.3.0
data InvalidAccess
InvalidAccess :: String -> InvalidAccess
[functionName] :: InvalidAccess -> String
class MonadBase b m => MonadBaseControl (b :: * -> *) (m :: * -> *) | m -> b

-- | The internal state held by a <tt>ResourceT</tt> transformer.
--   
--   Since 0.4.6
type InternalState = IORef ReleaseMap

-- | Get the internal state of the current <tt>ResourceT</tt>.
--   
--   Since 0.4.6
getInternalState :: Monad m => ResourceT m InternalState

-- | Unwrap a <tt>ResourceT</tt> using the given <tt>InternalState</tt>.
--   
--   Since 0.4.6
runInternalState :: ResourceT m a -> InternalState -> m a

-- | Run an action in the underlying monad, providing it the
--   <tt>InternalState</tt>.
--   
--   Since 0.4.6
withInternalState :: (InternalState -> m a) -> ResourceT m a

-- | Create a new internal state. This state must be closed with
--   <tt>closeInternalState</tt>. It is your responsibility to ensure
--   exception safety. Caveat emptor!
--   
--   Since 0.4.9
createInternalState :: MonadBase IO m => m InternalState

-- | Close an internal state created by <tt>createInternalState</tt>.
--   
--   Since 0.4.9
closeInternalState :: MonadBase IO m => InternalState -> m ()

-- | For backwards compatibility.
type ExceptionT = CatchT

-- | For backwards compatibility.
runExceptionT :: ExceptionT m a -> m (Either SomeException a)

-- | Same as <a>runExceptionT</a>, but immediately <a>throw</a> any
--   exception returned.
--   
--   Since 0.3.0
runExceptionT_ :: Monad m => ExceptionT m a -> m a

-- | Run an <tt>ExceptionT Identity</tt> stack.
--   
--   Since 0.4.2
runException :: ExceptionT Identity a -> Either SomeException a

-- | Run an <tt>ExceptionT Identity</tt> stack, but immediately
--   <a>throw</a> any exception returned.
--   
--   Since 0.4.2
runException_ :: ExceptionT Identity a -> a

-- | A class for monads in which exceptions may be thrown.
--   
--   Instances should obey the following law:
--   
--   <pre>
--   throwM e &gt;&gt; x = throwM e
--   </pre>
--   
--   In other words, throwing an exception short-circuits the rest of the
--   monadic computation.
class Monad m => MonadThrow (m :: * -> *)

-- | Throw an exception. Note that this throws when this action is run in
--   the monad <tt>m</tt>, not when it is applied. It is a generalization
--   of <a>Control.Exception</a>'s <a>throwIO</a>.
--   
--   Should satisfy the law:
--   
--   <pre>
--   throwM e &gt;&gt; f = throwM e
--   </pre>
throwM :: (MonadThrow m, Exception e) => e -> m a

-- | Backwards compatibility
monadThrow :: (Exception e, MonadThrow m) => e -> m a


-- | This was previously known as the Resource monad. However, that term is
--   confusing next to the ResourceT transformer, so it has been renamed.
module Data.Acquire

-- | A method for acquiring a scarce resource, providing the means of
--   freeing it when no longer needed. This data type provides
--   <tt>Functor</tt><i><tt>Applicative</tt></i><tt>Monad</tt> instances
--   for composing different resources together. You can allocate these
--   resources using either the <tt>bracket</tt> pattern (via
--   <tt>with</tt>) or using <tt>ResourceT</tt> (via
--   <tt>allocateAcquire</tt>).
--   
--   This concept was originally introduced by Gabriel Gonzalez and
--   described at:
--   <a>http://www.haskellforall.com/2013/06/the-resource-applicative.html</a>.
--   The implementation in this package is slightly different, due to
--   taking a different approach to async exception safety.
--   
--   Since 1.1.0
data Acquire a

-- | Allocate the given resource and provide it to the provided function.
--   The resource will be freed as soon as the inner block is exited,
--   whether normally or via an exception. This function is similar in
--   function to <tt>bracket</tt>.
--   
--   Since 1.1.0
with :: MonadBaseControl IO m => Acquire a -> (a -> m b) -> m b

-- | Same as <tt>with</tt>, but uses the <tt>MonadMask</tt> typeclass from
--   exceptions instead of <tt>MonadBaseControl</tt> from exceptions.
--   
--   Since 1.1.3
withEx :: (MonadMask m, MonadIO m) => Acquire a -> (a -> m b) -> m b

-- | Create an <tt>Acquire</tt> value using the given allocate and free
--   functions.
--   
--   Since 1.1.0
mkAcquire :: IO a -> (a -> IO ()) -> Acquire a

-- | Same as <a>mkAcquire</a>, but the cleanup function will be informed of
--   <i>how</i> cleanup was initiated. This allows you to distinguish, for
--   example, between normal and exceptional exits.
--   
--   Since 1.1.2
mkAcquireType :: IO a -> (a -> ReleaseType -> IO ()) -> Acquire a

-- | Allocate a resource and register an action with the
--   <tt>MonadResource</tt> to free the resource.
--   
--   Since 1.1.0
allocateAcquire :: MonadResource m => Acquire a -> m (ReleaseKey, a)

-- | The way in which a release is called.
--   
--   Since 1.1.2
data ReleaseType
ReleaseEarly :: ReleaseType
ReleaseNormal :: ReleaseType
ReleaseException :: ReleaseType
