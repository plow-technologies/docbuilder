-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Law-abiding lenses for aeson
--   
--   Law-abiding lenses for aeson
@package lens-aeson
@version 1.0.0.5


-- | This module also exports orphan <tt><a>Ixed</a> <a>Value</a></tt> and
--   <tt><a>Plated</a> <a>Value</a></tt> instances.
module Data.Aeson.Lens
class AsNumber t where _Number = _Primitive . _Number _Double = _Number . iso toRealFloat realToFrac _Integer = _Number . iso floor fromIntegral

-- | <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 0 . _Number
--   Just 1.0
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\"]" ^? nth 1 . _Number
--   Nothing
--   </pre>
_Number :: AsNumber t => Prism' t Scientific

-- | Prism into an <a>Double</a> over a <a>Value</a>, <a>Primitive</a> or
--   <a>Scientific</a>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.2]" ^? nth 0 . _Double
--   Just 10.2
--   </pre>
_Double :: AsNumber t => Prism' t Double

-- | Prism into an <a>Integer</a> over a <a>Value</a>, <a>Primitive</a> or
--   <a>Scientific</a>
--   
--   <pre>
--   &gt;&gt;&gt; "[10]" ^? nth 0 . _Integer
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.5]" ^? nth 0 . _Integer
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "42" ^? _Integer
--   Just 42
--   </pre>
_Integer :: AsNumber t => Prism' t Integer

-- | Access Integer <a>Value</a>s as Integrals.
--   
--   <pre>
--   &gt;&gt;&gt; "[10]" ^? nth 0 . _Integral
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[10.5]" ^? nth 0 . _Integral
--   Just 10
--   </pre>
_Integral :: (AsNumber t, Integral a) => Prism' t a

-- | Prism into non-<a>Null</a> values
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "a" . nonNull
--   Just (String "xyz")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "a" . nonNull
--   Just (Object (fromList []))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "b" . nonNull
--   Nothing
--   </pre>
nonNull :: Prism' Value Value

-- | Primitives of <a>Value</a>
data Primitive
StringPrim :: !Text -> Primitive
NumberPrim :: !Scientific -> Primitive
BoolPrim :: !Bool -> Primitive
NullPrim :: Primitive
class AsNumber t => AsPrimitive t where _Primitive = _Value . _Primitive _String = _Primitive . prism StringPrim (\ v -> case v of { StringPrim s -> Right s _ -> Left v }) _Bool = _Primitive . prism BoolPrim (\ v -> case v of { BoolPrim b -> Right b _ -> Left v }) _Null = _Primitive . prism (const NullPrim) (\ v -> case v of { NullPrim -> Right () _ -> Left v })

-- | <pre>
--   &gt;&gt;&gt; "[1, \"x\", null, true, false]" ^? nth 0 . _Primitive
--   Just (NumberPrim 1.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\", null, true, false]" ^? nth 1 . _Primitive
--   Just (StringPrim "x")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\", null, true, false]" ^? nth 2 . _Primitive
--   Just NullPrim
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\", null, true, false]" ^? nth 3 . _Primitive
--   Just (BoolPrim True)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1, \"x\", null, true, false]" ^? nth 4 . _Primitive
--   Just (BoolPrim False)
--   </pre>
_Primitive :: AsPrimitive t => Prism' t Primitive

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "a" . _String
--   Just "xyz"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "b" . _String
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Object._Wrapped # [("key" :: Text, _String # "value")] :: String
--   "{\"key\":\"value\"}"
--   </pre>
_String :: AsPrimitive t => Prism' t Text

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "b" . _Bool
--   Just True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": true}" ^? key "a" . _Bool
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Bool # True :: String
--   "true"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Bool # False :: String
--   "false"
--   </pre>
_Bool :: AsPrimitive t => Prism' t Bool

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "b" . _Null
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": \"xyz\", \"b\": null}" ^? key "a" . _Null
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Null # () :: String
--   "null"
--   </pre>
_Null :: AsPrimitive t => Prism' t ()
class AsPrimitive t => AsValue t where _Object = _Value . prism Object (\ v -> case v of { Object o -> Right o _ -> Left v }) _Array = _Value . prism Array (\ v -> case v of { Array a -> Right a _ -> Left v })

-- | <pre>
--   &gt;&gt;&gt; preview _Value "[1,2,3]" == Just (Array (Vector.fromList [Number 1.0,Number 2.0,Number 3.0]))
--   True
--   </pre>
_Value :: AsValue t => Prism' t Value

-- | <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "a" . _Object
--   Just (fromList [])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": {}, \"b\": null}" ^? key "b" . _Object
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Object._Wrapped # [("key" :: Text, _String # "value")] :: String
--   "{\"key\":\"value\"}"
--   </pre>
_Object :: AsValue t => Prism' t (HashMap Text Value)

-- | <pre>
--   &gt;&gt;&gt; preview _Array "[1,2,3]" == Just (Vector.fromList [Number 1.0,Number 2.0,Number 3.0])
--   True
--   </pre>
_Array :: AsValue t => Prism' t (Vector Value)

-- | Like <a>ix</a>, but for <a>Object</a> with Text indices. This often
--   has better inference than <a>ix</a> when used with OverloadedStrings.
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 100, \"b\": 200}" ^? key "a"
--   Just (Number 100.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^? key "a"
--   Nothing
--   </pre>
key :: AsValue t => Text -> Traversal' t Value

-- | An indexed Traversal into Object properties
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 4, \"b\": 7}" ^@.. members
--   [("a",Number 4.0),("b",Number 7.0)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "{\"a\": 4, \"b\": 7}" &amp; members . _Number *~ 10
--   "{\"a\":40,\"b\":70}"
--   </pre>
members :: AsValue t => IndexedTraversal' Text t Value

-- | Like <a>ix</a>, but for Arrays with Int indexes
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^? nth 1
--   Just (Number 2.0)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "\"a\": 100, \"b\": 200}" ^? nth 1
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" &amp; nth 1 .~ Number 20
--   "[1,20,3]"
--   </pre>
nth :: AsValue t => Int -> Traversal' t Value

-- | An indexed Traversal into Array elements
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" ^.. values
--   [Number 1.0,Number 2.0,Number 3.0]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "[1,2,3]" &amp; values . _Number *~ 10
--   "[10,20,30]"
--   </pre>
values :: AsValue t => IndexedTraversal' Int t Value
class AsJSON t

-- | <a>_JSON</a> is a <a>Prism</a> from something containing JSON to
--   something encoded in that structure
_JSON :: (AsJSON t, FromJSON a, ToJSON a) => Prism' t a
instance Data.Data.Data Data.Aeson.Lens.Primitive
instance GHC.Show.Show Data.Aeson.Lens.Primitive
instance GHC.Classes.Ord Data.Aeson.Lens.Primitive
instance GHC.Classes.Eq Data.Aeson.Lens.Primitive
instance Data.Aeson.Lens.AsNumber Data.Aeson.Types.Internal.Value
instance Data.Aeson.Lens.AsNumber Data.Scientific.Scientific
instance Data.Aeson.Lens.AsNumber Data.ByteString.Internal.ByteString
instance Data.Aeson.Lens.AsNumber Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsNumber Data.Text.Internal.Text
instance Data.Aeson.Lens.AsNumber Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsNumber GHC.Base.String
instance Data.Aeson.Lens.AsNumber Data.Aeson.Lens.Primitive
instance Data.Aeson.Lens.AsPrimitive Data.Aeson.Types.Internal.Value
instance Data.Aeson.Lens.AsPrimitive Data.ByteString.Internal.ByteString
instance Data.Aeson.Lens.AsPrimitive Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsPrimitive Data.Text.Internal.Text
instance Data.Aeson.Lens.AsPrimitive Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsPrimitive GHC.Base.String
instance Data.Aeson.Lens.AsPrimitive Data.Aeson.Lens.Primitive
instance Data.Aeson.Lens.AsValue Data.Aeson.Types.Internal.Value
instance Data.Aeson.Lens.AsValue Data.ByteString.Internal.ByteString
instance Data.Aeson.Lens.AsValue Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsValue GHC.Base.String
instance Data.Aeson.Lens.AsValue Data.Text.Internal.Text
instance Data.Aeson.Lens.AsValue Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsJSON Data.ByteString.Internal.ByteString
instance Data.Aeson.Lens.AsJSON Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Lens.AsJSON GHC.Base.String
instance Data.Aeson.Lens.AsJSON Data.Text.Internal.Text
instance Data.Aeson.Lens.AsJSON Data.Text.Internal.Lazy.Text
instance Data.Aeson.Lens.AsJSON Data.Aeson.Types.Internal.Value
instance Control.Lens.At.Ixed Data.Aeson.Types.Internal.Value
instance Control.Lens.Plated.Plated Data.Aeson.Types.Internal.Value
