-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A regular expression library for W3C XML Schema regular expressions
--   
--   This library supports full W3C XML Schema regular expressions
--   inclusive all Unicode character sets and blocks. The complete grammar
--   can be found under <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>.
--   It is implemented by the technique of derivations of regular
--   expressions.
--   
--   The W3C syntax is extended to support not only union of regular sets,
--   but also intersection, set difference, exor. Matching of
--   subexpressions is also supported.
--   
--   The library can be used for constricting lightweight scanners and
--   tokenizers. It is a standalone library, no external regex libraries
--   are used.
--   
--   Extensions in 9.2: The library does nor only support String's, but
--   also ByteString's and Text in strict and lazy variants
@package hxt-regex-xmlschema
@version 9.2.0.2


module Text.Regex.XMLSchema.Generic.StringLike

-- | <i>WARNING</i>: This StringLike class is <i>not</i> intended for use
--   outside this regex library. It provides an abstraction for String's as
--   used inside this library. It allows the library to work with String
--   (list of Char), ByteString.Char8, ByteString.Lazy.Char8, Data.Text and
--   Data.Text.Lazy.
--   
--   The class is similar to the StringLike class in the tagsoup package
class (Eq a, IsString a, Show a) => StringLike a where nullS = isNothing . uncons headS (uncons -> Just (c, _)) = c headS _ = error "headS: empty StringLike" concatS = foldl appendS emptyS
emptyS :: StringLike a => a
uncons :: StringLike a => a -> Maybe (Char, a)
nullS :: StringLike a => a -> Bool
headS :: StringLike a => a -> Char
takeS :: StringLike a => Int -> a -> a
dropS :: StringLike a => Int -> a -> a
appendS :: StringLike a => a -> a -> a
concatS :: StringLike a => [a] -> a
toString :: StringLike a => a -> String
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike GHC.Base.String
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike Data.Text.Internal.Text
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike Data.Text.Internal.Lazy.Text
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike Data.ByteString.Internal.ByteString
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike Data.ByteString.Lazy.Internal.ByteString


-- | W3C XML Schema Regular Expression Matcher
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.Generic.Regex
data GenRegex s

-- | construct the r.e. for the empty set. An (error-) message may be
--   attached
mkZero :: s -> GenRegex s
mkZero' :: (StringLike s) => String -> GenRegex s

-- | construct the r.e. for the set containing the empty word
mkUnit :: GenRegex s

-- | construct the r.e. for a set of chars
mkSym :: (StringLike s) => CharSet -> GenRegex s

-- | construct an r.e. for a single char set
mkSym1 :: (StringLike s) => Char -> GenRegex s

-- | construct an r.e. for an intervall of chars
mkSymRng :: (StringLike s) => Char -> Char -> GenRegex s

-- | mkSym generaized for strings
mkWord :: (StringLike s) => [Char] -> GenRegex s

-- | construct an r.e. for the set of all Unicode chars
mkDot :: GenRegex s

-- | construct r.e. for r*
mkStar :: (StringLike s) => GenRegex s -> GenRegex s

-- | construct an r.e. for the set of all Unicode words
mkAll :: (StringLike s) => GenRegex s

-- | construct the r.e for r1|r2
mkAlt :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | construct the r.e. for r1{|}r2 (r1 orElse r2).
--   
--   This represents the same r.e. as r1|r2, but when collecting the
--   results of subexpressions in (...) and r1 succeeds, the subexpressions
--   of r2 are discarded, so r1 matches are prioritized
--   
--   example
--   
--   <pre>
--   splitSubex "({1}x)|({2}.)"   "x" = ([("1","x"),("2","x")], "")
--   
--   splitSubex "({1}x){|}({2}.)" "x" = ([("1","x")], "")
--   </pre>
mkElse :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the sequence r.e. r1.r2
mkSeq :: GenRegex s -> GenRegex s -> GenRegex s

-- | mkSeq extened to lists
mkSeqs :: [GenRegex s] -> GenRegex s

-- | Construct repetition r{i,}
mkRep :: (StringLike s) => Int -> GenRegex s -> GenRegex s

-- | Construct range r{i,j}
mkRng :: (StringLike s) => Int -> Int -> GenRegex s -> GenRegex s

-- | Construct option r?
mkOpt :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct difference r.e.: r1 {\} r2
--   
--   example
--   
--   <pre>
--   match "[a-z]+{\\}bush" "obama"     = True
--   match "[a-z]+{\\}bush" "clinton"   = True
--   match "[a-z]+{\\}bush" "bush"      = False     -- not important any more
--   </pre>
mkDiff :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for intersection: r1 {&amp;} r2
--   
--   example
--   
--   <pre>
--   match ".*a.*{&amp;}.*b.*" "-a-b-"  = True
--   match ".*a.*{&amp;}.*b.*" "-b-a-"  = True
--   match ".*a.*{&amp;}.*b.*" "-a-a-"  = False
--   match ".*a.*{&amp;}.*b.*" "---b-"  = False
--   </pre>
mkIsect :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for exclusive or: r1 {^} r2
--   
--   example
--   
--   <pre>
--   match "[a-c]+{^}[c-d]+" "abc"  = True
--   match "[a-c]+{^}[c-d]+" "acdc" = False
--   match "[a-c]+{^}[c-d]+" "ccc"  = False
--   match "[a-c]+{^}[c-d]+" "cdc"  = True
--   </pre>
mkExor :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s
mkInterleave :: GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the Complement of an r.e.: whole set of words - r
mkCompl :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct a labeled subexpression: ({label}r)
mkBr :: s -> GenRegex s -> GenRegex s
mkBr' :: StringLike s => String -> GenRegex s -> GenRegex s
isZero :: GenRegex s -> Bool
errRegex :: (StringLike s) => GenRegex s -> s
nullable :: (StringLike s) => GenRegex s -> Bool
nullable' :: (StringLike s) => GenRegex s -> Nullable s
delta1 :: (StringLike s) => Char -> s -> GenRegex s -> GenRegex s
delta :: (StringLike s) => s -> GenRegex s -> GenRegex s

-- | FIRST for regular expressions
--   
--   this is only an approximation, the real set of char may be smaller,
--   when the expression contains intersection, set difference or exor
--   operators
firstChars :: (StringLike s) => GenRegex s -> CharSet
matchWithRegex :: (StringLike s) => GenRegex s -> s -> Bool
matchWithRegex' :: (StringLike s) => GenRegex s -> s -> Maybe (SubexResults s)

-- | This function wraps the whole regex in a subexpression before starting
--   the parse. This is done for getting access to the whole parsed string.
--   Therfore we need one special label, this label is the Nothing value,
--   all explicit labels are Just labels.
splitWithRegex :: (StringLike s) => GenRegex s -> s -> Maybe (SubexResults s, s)

-- | The main scanner function
splitWithRegex' :: (StringLike s) => GenRegex s -> s -> Maybe (GenRegex s, s)
splitWithRegexCS :: (StringLike s) => GenRegex s -> CharSet -> s -> Maybe (SubexResults s, s)

-- | speedup version for splitWithRegex'
--   
--   This function checks whether the input starts with a char from FIRST
--   re. If this is not the case, the split fails. The FIRST set can be
--   computed once for a whole tokenizer and reused by every call of split
splitWithRegexCS' :: (StringLike s) => GenRegex s -> CharSet -> s -> Maybe (GenRegex s, s)
instance GHC.Classes.Ord s => GHC.Classes.Ord (Text.Regex.XMLSchema.Generic.Regex.GenRegex s)
instance GHC.Classes.Eq s => GHC.Classes.Eq (Text.Regex.XMLSchema.Generic.Regex.GenRegex s)
instance Text.Regex.XMLSchema.Generic.StringLike.StringLike s => GHC.Show.Show (Text.Regex.XMLSchema.Generic.Regex.GenRegex s)


-- | W3C XML Schema Regular Expression Parser
--   
--   This parser supports the full W3C standard, the complete grammar can
--   be found under <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a> and
--   extensions for all missing set operations, intersection, difference,
--   exclusive or, interleave, complement
module Text.Regex.XMLSchema.Generic.RegexParser

-- | parse a standard W3C XML Schema regular expression
parseRegex :: StringLike s => s -> GenRegex s

-- | parse an extended syntax W3C XML Schema regular expression
--   
--   The Syntax of the W3C XML Schema spec is extended by further useful
--   set operations, like intersection, difference, exor. Subexpression
--   match becomes possible with "named" pairs of parentheses. The multi
--   char escape sequence \a represents any Unicode char, The multi char
--   escape sequence \A represents any Unicode word, (\A = \a*). All
--   syntactically wrong inputs are mapped to the Zero expression
--   representing the empty set of words. Zero contains as data field a
--   string for an error message. So error checking after parsing becomes
--   possible by checking against Zero (<a>isZero</a> predicate)
parseRegexExt :: StringLike s => s -> GenRegex s
parseRegex' :: StringLike s => String -> GenRegex s
parseRegexExt' :: StringLike s => String -> GenRegex s

-- | parse a regular expression surrounded by contenxt spec
--   
--   a leading <tt>^</tt> denotes start of text, a trailing <tt>$</tt>
--   denotes end of text, a leading <tt>\&lt;</tt> denotes word start, a
--   trailing <tt>\&gt;</tt> denotes word end.
--   
--   The 1. param ist the regex parser (<a>parseRegex</a> or
--   <a>parseRegexExt</a>)
parseContextRegex :: StringLike s => (String -> GenRegex s) -> s -> GenRegex s


-- | Convenient functions for W3C XML Schema Regular Expression Matcher.
--   For internals see <a>Regex</a>
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.Generic.Matching

-- | grep like filter for lists of strings
--   
--   The regular expression may be prefixed with the usual context spec "^"
--   for start of string, and "\&lt;" for start of word. and suffixed with
--   "$" for end of text and "\&gt;" end of word. Word chars are defined by
--   the multi char escape sequence "\w"
--   
--   Examples
--   
--   <pre>
--   grep "a"    ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a_", "_a", "a_", "a"]
--   grep "^a"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a_", "a"]
--   grep "a$"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a", "a"]
--   grep "^a$"  ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a"]
--   grep "\\&lt;a" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " ax "]
--   grep "a\\&gt;" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " xa "]
--   </pre>
grep :: StringLike s => s -> [s] -> [s]

-- | grep with extended regular expressions
grepExt :: StringLike s => s -> [s] -> [s]

-- | grep with already prepared Regex (ususally with
--   <a>parseContextRegex</a>)
grepRE :: StringLike s => GenRegex s -> [s] -> [s]

-- | grep with Regex and line numbers
grepREwithLineNum :: StringLike s => GenRegex s -> [s] -> [(Int, s)]

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   match "x*" "xxx" = True
--   match "x" "xxx"  = False
--   match "[" "xxx"  = False
--   </pre>
match :: StringLike s => s -> s -> Bool

-- | match with extended regular expressions
matchExt :: StringLike s => s -> s -> Bool

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   matchSubex "({1}x*)"                 "xxx"      = [("1","xxx")]
--   matchSubex "({1}x*)"                 "y"        = []
--   matchSubex "({w}[0-9]+)x({h}[0-9]+)" "800x600"  = [("w","800"),("h","600")]
--   matchSubex "[" "xxx"                            = []
--   </pre>
matchSubex :: StringLike s => s -> s -> [(s, s)]

-- | convenient function for <a>sedRE</a>
--   
--   examples:
--   
--   <pre>
--   sed (const "b") "a" "xaxax"       = "xbxbx"
--   sed (\ x -&gt; x ++ x) "a" "xax"     = "xaax"
--   sed undefined       "[" "xxx"     = "xxx"
--   </pre>
sed :: StringLike s => (s -> s) -> s -> s -> s
sedExt :: StringLike s => (s -> s) -> s -> s -> s

-- | convenient function for <a>splitRE</a>
--   
--   examples:
--   
--   <pre>
--   split "a*b" "abc" = ("ab","c")
--   split "a*"  "bc"  = ("", "bc")    -- "a*" matches ""
--   split "a+"  "bc"  = ("", "bc")    -- "a+" does not match, no split
--   split "["   "abc" = ("", "abc")   -- "["  syntax error, no split
--   </pre>
split :: StringLike s => s -> s -> (s, s)

-- | split with extended syntax
splitExt :: StringLike s => s -> s -> (s, s)

-- | convenient function for <a>splitSubex</a>, uses extended syntax
--   
--   examples:
--   
--   <pre>
--   splitSubex "({1}a*)b"  "abc" = ([("1","a")],"c")
--   splitSubex "({2}a*)"   "bc"  = ([("2","")], "bc")
--   splitSubex "({1}a|b)+" "abc" = ([("1","a"),("1","b")],"c")        -- subex 1 matches 2 times
--   
--   splitSubex ".*({x}a*)" "aa"  = ([("x",""),("x","a"),("x","aa")],"")
--                                                                     -- nondeterminism: 3 matches for a*
--   
--   splitSubex "({1}do)|({2}[a-z]+)" "do you know"
--                                  = ([("1","do"),("2","do")]," you know")
--                                                                     -- nondeterminism: 2 matches for do
--   
--   splitSubex "({1}do){|}({2}[a-z]+)" "do you know"
--                                  = ([("1","do")]," you know")
--                                                                     -- no nondeterminism with {|}: 1. match for do
--   
--   splitSubex "({1}a+)"   "bcd" = ([], "bcd")                        -- no match
--   splitSubex "["         "abc" = ([], "abc")                        -- syntax error
--   </pre>
splitSubex :: StringLike s => s -> s -> ([(s, s)], s)

-- | split a string into tokens (words) by giving a regular expression
--   which all tokens must match.
--   
--   Convenient function for <a>tokenizeRE</a>
--   
--   This can be used for simple tokenizers. It is recommended to use
--   regular expressions where the empty word does not match. Else there
--   will appear a lot of probably useless empty tokens in the output. All
--   none matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
--   
--   examples:
--   
--   <pre>
--   tokenize "a" "aabba"      = ["a","a","a"]
--   tokenize "a*" "aaaba"     = ["aaa","a"]
--   tokenize "a*" "bbb"       = ["","",""]
--   tokenize "a+" "bbb"       = []
--   
--   tokenize "a*b" ""         = []
--   tokenize "a*b" "abc"      = ["ab"]
--   tokenize "a*b" "abaab ab" = ["ab","aab","ab"]
--   
--   tokenize "[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+" "ab123 456.7abc"
--                             = ["ab","123","456.7","abc"]
--   
--   tokenize "[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+" "cab123 456.7abc"
--                             = ["cab","123","456.7","abc"]
--   
--   tokenize "[^ \t\n\r]*" "abc def\t\n\rxyz"
--                             = ["abc","def","xyz"]
--   
--   tokenize ".*"   "\nabc\n123\n\nxyz\n"
--                             = ["","abc","123","","xyz"]
--   
--   tokenize ".*"             = lines
--   
--   tokenize "[^ \t\n\r]*"    = words
--   </pre>
tokenize :: StringLike s => s -> s -> [s]

-- | tokenize with extended syntax
tokenizeExt :: StringLike s => s -> s -> [s]

-- | convenient function for <a>tokenizeRE'</a>
--   
--   When the regular expression parses as Zero, <tt>[Left input]</tt> is
--   returned, that means no tokens are found
tokenize' :: StringLike s => s -> s -> [Either s s]
tokenizeExt' :: StringLike s => s -> s -> [Either s s]

-- | convenient function for <a>tokenizeSubexRE</a> a string
--   
--   examples:
--   
--   <pre>
--   tokenizeSubex "({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)"
--                   "cab123 456.7abc"
--                                    = [("name","cab")
--                                      ,("num","123")
--                                      ,("real","456.7")
--                                      ,("name","abc")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                   "12.34"          = [("real","12.34")
--                                      ,("n","12")
--                                      ,("f","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                    "12 34"         = [("real","12"),("n","12")
--                                      ,("real","34"),("n","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))"
--                    "12 34.56"      = [("real","12"),("n","12"),("f","")
--                                      ,("real","34.56"),("n","34"),("f","56")]
--   </pre>
tokenizeSubex :: StringLike s => s -> s -> [(s, s)]

-- | match a string with a regular expression
matchRE :: StringLike s => GenRegex s -> s -> Bool

-- | match a string with a regular expression and extract subexpression
--   matches
matchSubexRE :: StringLike s => GenRegex s -> s -> [(s, s)]

-- | sed like editing function
--   
--   All matching tokens are edited by the 1. argument, the editing
--   function, all other chars remain as they are
sedRE :: StringLike s => (s -> s) -> GenRegex s -> s -> s

-- | split a string by taking the longest prefix matching a regular
--   expression
--   
--   <tt>Nothing</tt> is returned in case there is no matching prefix, else
--   the pair of prefix and rest is returned
splitRE :: StringLike s => GenRegex s -> s -> Maybe (s, s)

-- | split a string by removing the longest prefix matching a regular
--   expression and then return the list of subexpressions found in the
--   matching part
--   
--   <tt>Nothing</tt> is returned in case of no matching prefix, else the
--   list of pairs of labels and submatches and the rest is returned
splitSubexRE :: StringLike s => GenRegex s -> s -> Maybe ([(s, s)], s)

-- | The function, that does the real work for <a>tokenize</a>
tokenizeRE :: StringLike s => GenRegex s -> s -> [s]

-- | split a string into tokens and delimierter by giving a regular
--   expression which all tokens must match
--   
--   This is a generalisation of the above <a>tokenizeRE</a> functions. The
--   none matching char sequences are marked with <tt>Left</tt>, the
--   matching ones are marked with <tt>Right</tt>
--   
--   If the regular expression contains syntax errors <tt>Nothing</tt> is
--   returned
--   
--   The following Law holds:
--   
--   <pre>
--   concat . map (either id id) . tokenizeRE' re == id
--   </pre>
tokenizeRE' :: StringLike s => GenRegex s -> s -> [Either s s]

-- | split a string into tokens (pair of labels and words) by giving a
--   regular expression containing labeled subexpressions.
--   
--   This function should not be called with regular expressions without
--   any labeled subexpressions. This does not make sense, because the
--   result list will always be empty.
--   
--   Result is the list of matching subexpressions This can be used for
--   simple tokenizers. At least one char is consumed by parsing a token.
--   The pairs in the result list contain the matching substrings. All none
--   matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
tokenizeSubexRE :: StringLike s => GenRegex s -> s -> [(s, s)]


-- | Convenient functions for W3C XML Schema Regular Expression Matcher.
--   For internals see <a>Regex</a> and <a>Matching</a>
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>
module Text.Regex.XMLSchema.Generic
data GenRegex s
type Regex = GenRegex String
type RegexText = GenRegex Text
type RegexTextLazy = GenRegex Text
type RegexByteString = GenRegex ByteString
type RegexByteStringLazy = GenRegex ByteString

-- | grep like filter for lists of strings
--   
--   The regular expression may be prefixed with the usual context spec "^"
--   for start of string, and "\&lt;" for start of word. and suffixed with
--   "$" for end of text and "\&gt;" end of word. Word chars are defined by
--   the multi char escape sequence "\w"
--   
--   Examples
--   
--   <pre>
--   grep "a"    ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a_", "_a", "a_", "a"]
--   grep "^a"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a_", "a"]
--   grep "a$"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a", "a"]
--   grep "^a$"  ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a"]
--   grep "\\&lt;a" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " ax "]
--   grep "a\\&gt;" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " xa "]
--   </pre>
grep :: StringLike s => s -> [s] -> [s]

-- | grep with extended regular expressions
grepExt :: StringLike s => s -> [s] -> [s]

-- | grep with already prepared Regex (ususally with
--   <a>parseContextRegex</a>)
grepRE :: StringLike s => GenRegex s -> [s] -> [s]

-- | grep with Regex and line numbers
grepREwithLineNum :: StringLike s => GenRegex s -> [s] -> [(Int, s)]

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   match "x*" "xxx" = True
--   match "x" "xxx"  = False
--   match "[" "xxx"  = False
--   </pre>
match :: StringLike s => s -> s -> Bool

-- | match with extended regular expressions
matchExt :: StringLike s => s -> s -> Bool

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   matchSubex "({1}x*)"                 "xxx"      = [("1","xxx")]
--   matchSubex "({1}x*)"                 "y"        = []
--   matchSubex "({w}[0-9]+)x({h}[0-9]+)" "800x600"  = [("w","800"),("h","600")]
--   matchSubex "[" "xxx"                            = []
--   </pre>
matchSubex :: StringLike s => s -> s -> [(s, s)]

-- | convenient function for <a>sedRE</a>
--   
--   examples:
--   
--   <pre>
--   sed (const "b") "a" "xaxax"       = "xbxbx"
--   sed (\ x -&gt; x ++ x) "a" "xax"     = "xaax"
--   sed undefined       "[" "xxx"     = "xxx"
--   </pre>
sed :: StringLike s => (s -> s) -> s -> s -> s
sedExt :: StringLike s => (s -> s) -> s -> s -> s

-- | convenient function for <a>splitRE</a>
--   
--   examples:
--   
--   <pre>
--   split "a*b" "abc" = ("ab","c")
--   split "a*"  "bc"  = ("", "bc")    -- "a*" matches ""
--   split "a+"  "bc"  = ("", "bc")    -- "a+" does not match, no split
--   split "["   "abc" = ("", "abc")   -- "["  syntax error, no split
--   </pre>
split :: StringLike s => s -> s -> (s, s)

-- | split with extended syntax
splitExt :: StringLike s => s -> s -> (s, s)

-- | convenient function for <a>splitSubex</a>, uses extended syntax
--   
--   examples:
--   
--   <pre>
--   splitSubex "({1}a*)b"  "abc" = ([("1","a")],"c")
--   splitSubex "({2}a*)"   "bc"  = ([("2","")], "bc")
--   splitSubex "({1}a|b)+" "abc" = ([("1","a"),("1","b")],"c")        -- subex 1 matches 2 times
--   
--   splitSubex ".*({x}a*)" "aa"  = ([("x",""),("x","a"),("x","aa")],"")
--                                                                     -- nondeterminism: 3 matches for a*
--   
--   splitSubex "({1}do)|({2}[a-z]+)" "do you know"
--                                  = ([("1","do"),("2","do")]," you know")
--                                                                     -- nondeterminism: 2 matches for do
--   
--   splitSubex "({1}do){|}({2}[a-z]+)" "do you know"
--                                  = ([("1","do")]," you know")
--                                                                     -- no nondeterminism with {|}: 1. match for do
--   
--   splitSubex "({1}a+)"   "bcd" = ([], "bcd")                        -- no match
--   splitSubex "["         "abc" = ([], "abc")                        -- syntax error
--   </pre>
splitSubex :: StringLike s => s -> s -> ([(s, s)], s)

-- | split a string into tokens (words) by giving a regular expression
--   which all tokens must match.
--   
--   Convenient function for <a>tokenizeRE</a>
--   
--   This can be used for simple tokenizers. It is recommended to use
--   regular expressions where the empty word does not match. Else there
--   will appear a lot of probably useless empty tokens in the output. All
--   none matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
--   
--   examples:
--   
--   <pre>
--   tokenize "a" "aabba"      = ["a","a","a"]
--   tokenize "a*" "aaaba"     = ["aaa","a"]
--   tokenize "a*" "bbb"       = ["","",""]
--   tokenize "a+" "bbb"       = []
--   
--   tokenize "a*b" ""         = []
--   tokenize "a*b" "abc"      = ["ab"]
--   tokenize "a*b" "abaab ab" = ["ab","aab","ab"]
--   
--   tokenize "[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+" "ab123 456.7abc"
--                             = ["ab","123","456.7","abc"]
--   
--   tokenize "[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+" "cab123 456.7abc"
--                             = ["cab","123","456.7","abc"]
--   
--   tokenize "[^ \t\n\r]*" "abc def\t\n\rxyz"
--                             = ["abc","def","xyz"]
--   
--   tokenize ".*"   "\nabc\n123\n\nxyz\n"
--                             = ["","abc","123","","xyz"]
--   
--   tokenize ".*"             = lines
--   
--   tokenize "[^ \t\n\r]*"    = words
--   </pre>
tokenize :: StringLike s => s -> s -> [s]

-- | tokenize with extended syntax
tokenizeExt :: StringLike s => s -> s -> [s]

-- | convenient function for <a>tokenizeRE'</a>
--   
--   When the regular expression parses as Zero, <tt>[Left input]</tt> is
--   returned, that means no tokens are found
tokenize' :: StringLike s => s -> s -> [Either s s]
tokenizeExt' :: StringLike s => s -> s -> [Either s s]

-- | convenient function for <a>tokenizeSubexRE</a> a string
--   
--   examples:
--   
--   <pre>
--   tokenizeSubex "({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)"
--                   "cab123 456.7abc"
--                                    = [("name","cab")
--                                      ,("num","123")
--                                      ,("real","456.7")
--                                      ,("name","abc")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                   "12.34"          = [("real","12.34")
--                                      ,("n","12")
--                                      ,("f","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                    "12 34"         = [("real","12"),("n","12")
--                                      ,("real","34"),("n","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))"
--                    "12 34.56"      = [("real","12"),("n","12"),("f","")
--                                      ,("real","34.56"),("n","34"),("f","56")]
--   </pre>
tokenizeSubex :: StringLike s => s -> s -> [(s, s)]

-- | match a string with a regular expression
matchRE :: StringLike s => GenRegex s -> s -> Bool

-- | match a string with a regular expression and extract subexpression
--   matches
matchSubexRE :: StringLike s => GenRegex s -> s -> [(s, s)]

-- | sed like editing function
--   
--   All matching tokens are edited by the 1. argument, the editing
--   function, all other chars remain as they are
sedRE :: StringLike s => (s -> s) -> GenRegex s -> s -> s

-- | split a string by taking the longest prefix matching a regular
--   expression
--   
--   <tt>Nothing</tt> is returned in case there is no matching prefix, else
--   the pair of prefix and rest is returned
splitRE :: StringLike s => GenRegex s -> s -> Maybe (s, s)

-- | split a string by removing the longest prefix matching a regular
--   expression and then return the list of subexpressions found in the
--   matching part
--   
--   <tt>Nothing</tt> is returned in case of no matching prefix, else the
--   list of pairs of labels and submatches and the rest is returned
splitSubexRE :: StringLike s => GenRegex s -> s -> Maybe ([(s, s)], s)

-- | The function, that does the real work for <a>tokenize</a>
tokenizeRE :: StringLike s => GenRegex s -> s -> [s]

-- | split a string into tokens and delimierter by giving a regular
--   expression which all tokens must match
--   
--   This is a generalisation of the above <a>tokenizeRE</a> functions. The
--   none matching char sequences are marked with <tt>Left</tt>, the
--   matching ones are marked with <tt>Right</tt>
--   
--   If the regular expression contains syntax errors <tt>Nothing</tt> is
--   returned
--   
--   The following Law holds:
--   
--   <pre>
--   concat . map (either id id) . tokenizeRE' re == id
--   </pre>
tokenizeRE' :: StringLike s => GenRegex s -> s -> [Either s s]

-- | split a string into tokens (pair of labels and words) by giving a
--   regular expression containing labeled subexpressions.
--   
--   This function should not be called with regular expressions without
--   any labeled subexpressions. This does not make sense, because the
--   result list will always be empty.
--   
--   Result is the list of matching subexpressions This can be used for
--   simple tokenizers. At least one char is consumed by parsing a token.
--   The pairs in the result list contain the matching substrings. All none
--   matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
tokenizeSubexRE :: StringLike s => GenRegex s -> s -> [(s, s)]

-- | construct the r.e. for the empty set. An (error-) message may be
--   attached
mkZero :: s -> GenRegex s
mkZero' :: (StringLike s) => String -> GenRegex s

-- | construct the r.e. for the set containing the empty word
mkUnit :: GenRegex s

-- | construct an r.e. for a single char set
mkSym1 :: (StringLike s) => Char -> GenRegex s

-- | construct an r.e. for an intervall of chars
mkSymRng :: (StringLike s) => Char -> Char -> GenRegex s

-- | mkSym generaized for strings
mkWord :: (StringLike s) => [Char] -> GenRegex s

-- | construct an r.e. for the set of all Unicode chars
mkDot :: GenRegex s

-- | construct r.e. for r*
mkStar :: (StringLike s) => GenRegex s -> GenRegex s

-- | construct an r.e. for the set of all Unicode words
mkAll :: (StringLike s) => GenRegex s

-- | construct the r.e for r1|r2
mkAlt :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | construct the r.e. for r1{|}r2 (r1 orElse r2).
--   
--   This represents the same r.e. as r1|r2, but when collecting the
--   results of subexpressions in (...) and r1 succeeds, the subexpressions
--   of r2 are discarded, so r1 matches are prioritized
--   
--   example
--   
--   <pre>
--   splitSubex "({1}x)|({2}.)"   "x" = ([("1","x"),("2","x")], "")
--   
--   splitSubex "({1}x){|}({2}.)" "x" = ([("1","x")], "")
--   </pre>
mkElse :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the sequence r.e. r1.r2
mkSeq :: GenRegex s -> GenRegex s -> GenRegex s

-- | mkSeq extened to lists
mkSeqs :: [GenRegex s] -> GenRegex s

-- | Construct repetition r{i,}
mkRep :: (StringLike s) => Int -> GenRegex s -> GenRegex s

-- | Construct range r{i,j}
mkRng :: (StringLike s) => Int -> Int -> GenRegex s -> GenRegex s

-- | Construct option r?
mkOpt :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct difference r.e.: r1 {\} r2
--   
--   example
--   
--   <pre>
--   match "[a-z]+{\\}bush" "obama"     = True
--   match "[a-z]+{\\}bush" "clinton"   = True
--   match "[a-z]+{\\}bush" "bush"      = False     -- not important any more
--   </pre>
mkDiff :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for intersection: r1 {&amp;} r2
--   
--   example
--   
--   <pre>
--   match ".*a.*{&amp;}.*b.*" "-a-b-"  = True
--   match ".*a.*{&amp;}.*b.*" "-b-a-"  = True
--   match ".*a.*{&amp;}.*b.*" "-a-a-"  = False
--   match ".*a.*{&amp;}.*b.*" "---b-"  = False
--   </pre>
mkIsect :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for exclusive or: r1 {^} r2
--   
--   example
--   
--   <pre>
--   match "[a-c]+{^}[c-d]+" "abc"  = True
--   match "[a-c]+{^}[c-d]+" "acdc" = False
--   match "[a-c]+{^}[c-d]+" "ccc"  = False
--   match "[a-c]+{^}[c-d]+" "cdc"  = True
--   </pre>
mkExor :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the Complement of an r.e.: whole set of words - r
mkCompl :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct a labeled subexpression: ({label}r)
mkBr :: s -> GenRegex s -> GenRegex s
mkBr' :: StringLike s => String -> GenRegex s -> GenRegex s
isZero :: GenRegex s -> Bool
errRegex :: (StringLike s) => GenRegex s -> s

-- | parse a standard W3C XML Schema regular expression
parseRegex :: StringLike s => s -> GenRegex s

-- | parse an extended syntax W3C XML Schema regular expression
--   
--   The Syntax of the W3C XML Schema spec is extended by further useful
--   set operations, like intersection, difference, exor. Subexpression
--   match becomes possible with "named" pairs of parentheses. The multi
--   char escape sequence \a represents any Unicode char, The multi char
--   escape sequence \A represents any Unicode word, (\A = \a*). All
--   syntactically wrong inputs are mapped to the Zero expression
--   representing the empty set of words. Zero contains as data field a
--   string for an error message. So error checking after parsing becomes
--   possible by checking against Zero (<a>isZero</a> predicate)
parseRegexExt :: StringLike s => s -> GenRegex s

-- | parse a regular expression surrounded by contenxt spec
--   
--   a leading <tt>^</tt> denotes start of text, a trailing <tt>$</tt>
--   denotes end of text, a leading <tt>\&lt;</tt> denotes word start, a
--   trailing <tt>\&gt;</tt> denotes word end.
--   
--   The 1. param ist the regex parser (<a>parseRegex</a> or
--   <a>parseRegexExt</a>)
parseContextRegex :: StringLike s => (String -> GenRegex s) -> s -> GenRegex s


-- | Convenient functions for W3C XML Schema Regular Expression Matcher for
--   Strings. A specialisation of Text.Regex.XMLSchema.Generic as
--   compatibility module to old non generic version
--   
--   Grammar can be found under
--   <a>http://www.w3.org/TR/xmlschema11-2/#regexs</a>

-- | <i>Deprecated: use the more general <a>Generic</a> instead</i>
module Text.Regex.XMLSchema.String
type Regex = GenRegex String

-- | grep like filter for lists of strings
--   
--   The regular expression may be prefixed with the usual context spec "^"
--   for start of string, and "\&lt;" for start of word. and suffixed with
--   "$" for end of text and "\&gt;" end of word. Word chars are defined by
--   the multi char escape sequence "\w"
--   
--   Examples
--   
--   <pre>
--   grep "a"    ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a_", "_a", "a_", "a"]
--   grep "^a"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a_", "a"]
--   grep "a$"   ["_a_", "_a", "a_", "a", "_"]      =&gt; ["_a", "a"]
--   grep "^a$"  ["_a_", "_a", "a_", "a", "_"]      =&gt; ["a"]
--   grep "\\&lt;a" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " ax "]
--   grep "a\\&gt;" ["x a b", " ax ", " xa ", "xab"]   =&gt; ["x a b", " xa "]
--   </pre>
grep :: String -> [String] -> [String]

-- | grep with extended regular expressions
grepExt :: String -> [String] -> [String]

-- | grep with already prepared Regex (ususally with
--   <a>parseContextRegex</a>)
grepRE :: Regex -> [String] -> [String]

-- | grep with Regex and line numbers
grepREwithLineNum :: Regex -> [String] -> [(Int, String)]

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   match "x*" "xxx" = True
--   match "x" "xxx"  = False
--   match "[" "xxx"  = False
--   </pre>
match :: String -> String -> Bool

-- | match with extended regular expressions
matchExt :: String -> String -> Bool

-- | convenient function for <a>matchRE</a>
--   
--   Examples:
--   
--   <pre>
--   matchSubex "({1}x*)"                 "xxx"      = [("1","xxx")]
--   matchSubex "({1}x*)"                 "y"        = []
--   matchSubex "({w}[0-9]+)x({h}[0-9]+)" "800x600"  = [("w","800"),("h","600")]
--   matchSubex "[" "xxx"                            = []
--   </pre>
matchSubex :: String -> String -> [(String, String)]

-- | convenient function for <a>sedRE</a>
--   
--   examples:
--   
--   <pre>
--   sed (const "b") "a" "xaxax"       = "xbxbx"
--   sed (\ x -&gt; x ++ x) "a" "xax"     = "xaax"
--   sed undefined       "[" "xxx"     = "xxx"
--   </pre>
sed :: (String -> String) -> String -> String -> String
sedExt :: (String -> String) -> String -> String -> String

-- | convenient function for <a>splitRE</a>
--   
--   examples:
--   
--   <pre>
--   split "a*b" "abc" = ("ab","c")
--   split "a*"  "bc"  = ("", "bc")    -- "a*" matches ""
--   split "a+"  "bc"  = ("", "bc")    -- "a+" does not match, no split
--   split "["   "abc" = ("", "abc")   -- "["  syntax error, no split
--   </pre>
split :: String -> String -> (String, String)

-- | split with extended syntax
splitExt :: String -> String -> (String, String)

-- | convenient function for <a>splitSubex</a>, uses extended syntax
--   
--   examples:
--   
--   <pre>
--   splitSubex "({1}a*)b"  "abc" = ([("1","a")],"c")
--   splitSubex "({2}a*)"   "bc"  = ([("2","")], "bc")
--   splitSubex "({1}a|b)+" "abc" = ([("1","a"),("1","b")],"c")        -- subex 1 matches 2 times
--   
--   splitSubex ".*({x}a*)" "aa"  = ([("x",""),("x","a"),("x","aa")],"")
--                                                                     -- nondeterminism: 3 matches for a*
--   
--   splitSubex "({1}do)|({2}[a-z]+)" "do you know"
--                                  = ([("1","do"),("2","do")]," you know")
--                                                                     -- nondeterminism: 2 matches for do
--   
--   splitSubex "({1}do){|}({2}[a-z]+)" "do you know"
--                                  = ([("1","do")]," you know")
--                                                                     -- no nondeterminism with {|}: 1. match for do
--   
--   splitSubex "({1}a+)"   "bcd" = ([], "bcd")                        -- no match
--   splitSubex "["         "abc" = ([], "abc")                        -- syntax error
--   </pre>
splitSubex :: String -> String -> ([(String, String)], String)

-- | split a string into tokens (words) by giving a regular expression
--   which all tokens must match.
--   
--   Convenient function for <a>tokenizeRE</a>
--   
--   This can be used for simple tokenizers. It is recommended to use
--   regular expressions where the empty word does not match. Else there
--   will appear a lot of probably useless empty tokens in the output. All
--   none matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
--   
--   examples:
--   
--   <pre>
--   tokenize "a" "aabba"      = ["a","a","a"]
--   tokenize "a*" "aaaba"     = ["aaa","a"]
--   tokenize "a*" "bbb"       = ["","",""]
--   tokenize "a+" "bbb"       = []
--   
--   tokenize "a*b" ""         = []
--   tokenize "a*b" "abc"      = ["ab"]
--   tokenize "a*b" "abaab ab" = ["ab","aab","ab"]
--   
--   tokenize "[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+" "ab123 456.7abc"
--                             = ["ab","123","456.7","abc"]
--   
--   tokenize "[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+" "cab123 456.7abc"
--                             = ["cab","123","456.7","abc"]
--   
--   tokenize "[^ \t\n\r]*" "abc def\t\n\rxyz"
--                             = ["abc","def","xyz"]
--   
--   tokenize ".*"   "\nabc\n123\n\nxyz\n"
--                             = ["","abc","123","","xyz"]
--   
--   tokenize ".*"             = lines
--   
--   tokenize "[^ \t\n\r]*"    = words
--   </pre>
tokenize :: String -> String -> [String]

-- | tokenize with extended syntax
tokenizeExt :: String -> String -> [String]

-- | convenient function for <a>tokenizeRE'</a>
--   
--   When the regular expression parses as Zero, <tt>[Left input]</tt> is
--   returned, that means no tokens are found
tokenize' :: String -> String -> [Either String String]
tokenizeExt' :: String -> String -> [Either String String]

-- | convenient function for <a>tokenizeSubexRE</a> a string
--   
--   examples:
--   
--   <pre>
--   tokenizeSubex "({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)"
--                   "cab123 456.7abc"
--                                    = [("name","cab")
--                                      ,("num","123")
--                                      ,("real","456.7")
--                                      ,("name","abc")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                   "12.34"          = [("real","12.34")
--                                      ,("n","12")
--                                      ,("f","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)([.]({f}[0-9]+))?)"
--                    "12 34"         = [("real","12"),("n","12")
--                                      ,("real","34"),("n","34")]
--   
--   tokenizeSubex "({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))"
--                    "12 34.56"      = [("real","12"),("n","12"),("f","")
--                                      ,("real","34.56"),("n","34"),("f","56")]
--   </pre>
tokenizeSubex :: String -> String -> [(String, String)]

-- | match a string with a regular expression
matchRE :: Regex -> String -> Bool

-- | match a string with a regular expression and extract subexpression
--   matches
matchSubexRE :: Regex -> String -> [(String, String)]

-- | sed like editing function
--   
--   All matching tokens are edited by the 1. argument, the editing
--   function, all other chars remain as they are
sedRE :: (String -> String) -> Regex -> String -> String

-- | split a string by taking the longest prefix matching a regular
--   expression
--   
--   <tt>Nothing</tt> is returned in case there is no matching prefix, else
--   the pair of prefix and rest is returned
splitRE :: Regex -> String -> Maybe (String, String)

-- | split a string by removing the longest prefix matching a regular
--   expression and then return the list of subexpressions found in the
--   matching part
--   
--   <tt>Nothing</tt> is returned in case of no matching prefix, else the
--   list of pairs of labels and submatches and the rest is returned
splitSubexRE :: Regex -> String -> Maybe ([(String, String)], String)

-- | The function, that does the real work for <a>tokenize</a>
tokenizeRE :: Regex -> String -> [String]

-- | split a string into tokens and delimierter by giving a regular
--   expression wich all tokens must match
--   
--   This is a generalisation of the above <a>tokenizeRE</a> functions. The
--   none matching char sequences are marked with <tt>Left</tt>, the
--   matching ones are marked with <tt>Right</tt>
--   
--   If the regular expression contains syntax errors <tt>Nothing</tt> is
--   returned
--   
--   The following Law holds:
--   
--   <pre>
--   concat . map (either id id) . tokenizeRE' re == id
--   </pre>
tokenizeRE' :: Regex -> String -> [Either String String]

-- | split a string into tokens (pair of labels and words) by giving a
--   regular expression containing labeled subexpressions.
--   
--   This function should not be called with regular expressions without
--   any labeled subexpressions. This does not make sense, because the
--   result list will always be empty.
--   
--   Result is the list of matching subexpressions This can be used for
--   simple tokenizers. At least one char is consumed by parsing a token.
--   The pairs in the result list contain the matching substrings. All none
--   matching chars are discarded. If the given regex contains syntax
--   errors, <tt>Nothing</tt> is returned
tokenizeSubexRE :: Regex -> String -> [(String, String)]

-- | construct the r.e. for the empty set. An (error-) message may be
--   attached
mkZero :: s -> GenRegex s

-- | construct the r.e. for the set containing the empty word
mkUnit :: GenRegex s

-- | construct an r.e. for a single char set
mkSym1 :: (StringLike s) => Char -> GenRegex s

-- | construct an r.e. for an intervall of chars
mkSymRng :: (StringLike s) => Char -> Char -> GenRegex s

-- | mkSym generaized for strings
mkWord :: (StringLike s) => [Char] -> GenRegex s

-- | construct an r.e. for the set of all Unicode chars
mkDot :: GenRegex s

-- | construct r.e. for r*
mkStar :: (StringLike s) => GenRegex s -> GenRegex s

-- | construct an r.e. for the set of all Unicode words
mkAll :: (StringLike s) => GenRegex s

-- | construct the r.e for r1|r2
mkAlt :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | construct the r.e. for r1{|}r2 (r1 orElse r2).
--   
--   This represents the same r.e. as r1|r2, but when collecting the
--   results of subexpressions in (...) and r1 succeeds, the subexpressions
--   of r2 are discarded, so r1 matches are prioritized
--   
--   example
--   
--   <pre>
--   splitSubex "({1}x)|({2}.)"   "x" = ([("1","x"),("2","x")], "")
--   
--   splitSubex "({1}x){|}({2}.)" "x" = ([("1","x")], "")
--   </pre>
mkElse :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the sequence r.e. r1.r2
mkSeq :: GenRegex s -> GenRegex s -> GenRegex s

-- | mkSeq extened to lists
mkSeqs :: [GenRegex s] -> GenRegex s

-- | Construct repetition r{i,}
mkRep :: (StringLike s) => Int -> GenRegex s -> GenRegex s

-- | Construct range r{i,j}
mkRng :: (StringLike s) => Int -> Int -> GenRegex s -> GenRegex s

-- | Construct option r?
mkOpt :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct difference r.e.: r1 {\} r2
--   
--   example
--   
--   <pre>
--   match "[a-z]+{\\}bush" "obama"     = True
--   match "[a-z]+{\\}bush" "clinton"   = True
--   match "[a-z]+{\\}bush" "bush"      = False     -- not important any more
--   </pre>
mkDiff :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for intersection: r1 {&amp;} r2
--   
--   example
--   
--   <pre>
--   match ".*a.*{&amp;}.*b.*" "-a-b-"  = True
--   match ".*a.*{&amp;}.*b.*" "-b-a-"  = True
--   match ".*a.*{&amp;}.*b.*" "-a-a-"  = False
--   match ".*a.*{&amp;}.*b.*" "---b-"  = False
--   </pre>
mkIsect :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct r.e. for exclusive or: r1 {^} r2
--   
--   example
--   
--   <pre>
--   match "[a-c]+{^}[c-d]+" "abc"  = True
--   match "[a-c]+{^}[c-d]+" "acdc" = False
--   match "[a-c]+{^}[c-d]+" "ccc"  = False
--   match "[a-c]+{^}[c-d]+" "cdc"  = True
--   </pre>
mkExor :: (StringLike s) => GenRegex s -> GenRegex s -> GenRegex s

-- | Construct the Complement of an r.e.: whole set of words - r
mkCompl :: (StringLike s) => GenRegex s -> GenRegex s

-- | Construct a labeled subexpression: ({label}r)
mkBr :: s -> GenRegex s -> GenRegex s
isZero :: GenRegex s -> Bool
errRegex :: (StringLike s) => GenRegex s -> s

-- | parse a standard W3C XML Schema regular expression
parseRegex :: StringLike s => s -> GenRegex s

-- | parse an extended syntax W3C XML Schema regular expression
--   
--   The Syntax of the W3C XML Schema spec is extended by further useful
--   set operations, like intersection, difference, exor. Subexpression
--   match becomes possible with "named" pairs of parentheses. The multi
--   char escape sequence \a represents any Unicode char, The multi char
--   escape sequence \A represents any Unicode word, (\A = \a*). All
--   syntactically wrong inputs are mapped to the Zero expression
--   representing the empty set of words. Zero contains as data field a
--   string for an error message. So error checking after parsing becomes
--   possible by checking against Zero (<a>isZero</a> predicate)
parseRegexExt :: StringLike s => s -> GenRegex s

-- | parse a regular expression surrounded by contenxt spec
--   
--   a leading <tt>^</tt> denotes start of text, a trailing <tt>$</tt>
--   denotes end of text, a leading <tt>\&lt;</tt> denotes word start, a
--   trailing <tt>\&gt;</tt> denotes word end.
--   
--   The 1. param ist the regex parser (<a>parseRegex</a> or
--   <a>parseRegexExt</a>)
parseContextRegex :: StringLike s => (String -> GenRegex s) -> s -> GenRegex s


-- | csh style Glob Pattern Parser for Regular Expressions
module Text.Regex.Glob.Generic.RegexParser

-- | parse a glob pattern
parseRegex :: StringLike s => s -> GenRegex s
parseRegexNoCase :: StringLike s => s -> GenRegex s


-- | csh glob style pattern matcher
module Text.Regex.Glob.Generic
data GenRegex s
type Regex = GenRegex String
type RegexText = GenRegex Text
type RegexTextLazy = GenRegex Text
type RegexByteString = GenRegex ByteString
type RegexByteStringLazy = GenRegex ByteString
match :: StringLike s => s -> s -> Bool
matchNoCase :: StringLike s => s -> s -> Bool

-- | parse a glob pattern
parseRegex :: StringLike s => s -> GenRegex s
parseRegexNoCase :: StringLike s => s -> GenRegex s


-- | csh glob style pattern matcher

-- | <i>Deprecated: use the more general <a>Generic</a> instead</i>
module Text.Regex.Glob.String
type Regex = GenRegex String
match :: String -> String -> Bool
matchNoCase :: String -> String -> Bool
parseRegex :: String -> Regex
parseRegexNoCase :: String -> Regex
