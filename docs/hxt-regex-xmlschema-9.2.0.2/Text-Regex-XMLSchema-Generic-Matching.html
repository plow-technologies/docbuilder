<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Text.Regex.XMLSchema.Generic.Matching</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Text-Regex-XMLSchema-Generic-Matching.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Text-Regex-XMLSchema-Generic-Matching.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">hxt-regex-xmlschema-9.2.0.2: A regular expression library for W3C XML Schema regular expressions</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Copyright (C) 2014- Uwe Schmidt</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Uwe Schmidt &lt;uwe@fh-wedel.de&gt;</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Text.Regex.XMLSchema.Generic.Matching</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Convenient functions for W3C XML Schema Regular Expression Matcher.
   For internals see <code><a href="Text-Regex-XMLSchema.html#v:Regex">Regex</a></code></p><p>Grammar can be found under <a href="http://www.w3.org/TR/xmlschema11-2/#regexs">http://www.w3.org/TR/xmlschema11-2/#regexs</a></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:grep">grep</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; [s] -&gt; [s]</li><li class="src short"><a href="#v:grepExt">grepExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; [s] -&gt; [s]</li><li class="src short"><a href="#v:grepRE">grepRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; [s] -&gt; [s]</li><li class="src short"><a href="#v:grepREwithLineNum">grepREwithLineNum</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; [s] -&gt; [(<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>, s)]</li><li class="src short"><a href="#v:match">match</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:matchExt">matchExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:matchSubex">matchSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [(s, s)]</li><li class="src short"><a href="#v:sed">sed</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; s -&gt; s -&gt; s</li><li class="src short"><a href="#v:sedExt">sedExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; s -&gt; s -&gt; s</li><li class="src short"><a href="#v:split">split</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; (s, s)</li><li class="src short"><a href="#v:splitExt">splitExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; (s, s)</li><li class="src short"><a href="#v:splitSubex">splitSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; ([(s, s)], s)</li><li class="src short"><a href="#v:tokenize">tokenize</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [s]</li><li class="src short"><a href="#v:tokenizeExt">tokenizeExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [s]</li><li class="src short"><a href="#v:tokenize-39-">tokenize'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s]</li><li class="src short"><a href="#v:tokenizeExt-39-">tokenizeExt'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s]</li><li class="src short"><a href="#v:tokenizeSubex">tokenizeSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [(s, s)]</li><li class="src short"><a href="#v:matchRE">matchRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:matchSubexRE">matchSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [(s, s)]</li><li class="src short"><a href="#v:sedRE">sedRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; s</li><li class="src short"><a href="#v:splitRE">splitRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> (s, s)</li><li class="src short"><a href="#v:splitSubexRE">splitSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> ([(s, s)], s)</li><li class="src short"><a href="#v:tokenizeRE">tokenizeRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [s]</li><li class="src short"><a href="#v:tokenizeRE-39-">tokenizeRE'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s]</li><li class="src short"><a href="#v:tokenizeSubexRE">tokenizeSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [(s, s)]</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:grep" class="def">grep</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; [s] -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#grep" class="link">Source</a></p><div class="doc"><p>grep like filter for lists of strings</p><p>The regular expression may be prefixed with the usual context spec &quot;^&quot; for start of string,
 and &quot;\&lt;&quot; for start of word.
 and suffixed with &quot;$&quot; for end of text and &quot;\&gt;&quot; end of word.
 Word chars are defined by the multi char escape sequence &quot;\w&quot;</p><p>Examples</p><pre>grep &quot;a&quot;    [&quot;_a_&quot;, &quot;_a&quot;, &quot;a_&quot;, &quot;a&quot;, &quot;_&quot;]      =&gt; [&quot;_a_&quot;, &quot;_a&quot;, &quot;a_&quot;, &quot;a&quot;]
grep &quot;^a&quot;   [&quot;_a_&quot;, &quot;_a&quot;, &quot;a_&quot;, &quot;a&quot;, &quot;_&quot;]      =&gt; [&quot;a_&quot;, &quot;a&quot;]
grep &quot;a$&quot;   [&quot;_a_&quot;, &quot;_a&quot;, &quot;a_&quot;, &quot;a&quot;, &quot;_&quot;]      =&gt; [&quot;_a&quot;, &quot;a&quot;]
grep &quot;^a$&quot;  [&quot;_a_&quot;, &quot;_a&quot;, &quot;a_&quot;, &quot;a&quot;, &quot;_&quot;]      =&gt; [&quot;a&quot;]
grep &quot;\\&lt;a&quot; [&quot;x a b&quot;, &quot; ax &quot;, &quot; xa &quot;, &quot;xab&quot;]   =&gt; [&quot;x a b&quot;, &quot; ax &quot;]
grep &quot;a\\&gt;&quot; [&quot;x a b&quot;, &quot; ax &quot;, &quot; xa &quot;, &quot;xab&quot;]   =&gt; [&quot;x a b&quot;, &quot; xa &quot;]</pre></div></div><div class="top"><p class="src"><a name="v:grepExt" class="def">grepExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; [s] -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#grepExt" class="link">Source</a></p><div class="doc"><p>grep with extended regular expressions</p></div></div><div class="top"><p class="src"><a name="v:grepRE" class="def">grepRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; [s] -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#grepRE" class="link">Source</a></p><div class="doc"><p>grep with already prepared Regex (ususally with <code><a href="Text-Regex-XMLSchema-Generic-RegexParser.html#v:parseContextRegex">parseContextRegex</a></code>)</p></div></div><div class="top"><p class="src"><a name="v:grepREwithLineNum" class="def">grepREwithLineNum</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; [s] -&gt; [(<a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a>, s)] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#grepREwithLineNum" class="link">Source</a></p><div class="doc"><p>grep with Regex and line numbers</p></div></div><div class="top"><p class="src"><a name="v:match" class="def">match</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#match" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:matchRE">matchRE</a></code></p><p>Examples:</p><pre>match &quot;x*&quot; &quot;xxx&quot; = True
match &quot;x&quot; &quot;xxx&quot;  = False
match &quot;[&quot; &quot;xxx&quot;  = False</pre></div></div><div class="top"><p class="src"><a name="v:matchExt" class="def">matchExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#matchExt" class="link">Source</a></p><div class="doc"><p>match with extended regular expressions</p></div></div><div class="top"><p class="src"><a name="v:matchSubex" class="def">matchSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [(s, s)] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#matchSubex" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:matchRE">matchRE</a></code></p><p>Examples:</p><pre>matchSubex &quot;({1}x*)&quot;                 &quot;xxx&quot;      = [(&quot;1&quot;,&quot;xxx&quot;)]
matchSubex &quot;({1}x*)&quot;                 &quot;y&quot;        = []
matchSubex &quot;({w}[0-9]+)x({h}[0-9]+)&quot; &quot;800x600&quot;  = [(&quot;w&quot;,&quot;800&quot;),(&quot;h&quot;,&quot;600&quot;)]
matchSubex &quot;[&quot; &quot;xxx&quot;                            = []</pre></div></div><div class="top"><p class="src"><a name="v:sed" class="def">sed</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; s -&gt; s -&gt; s <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#sed" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:sedRE">sedRE</a></code></p><p>examples:</p><pre>sed (const &quot;b&quot;) &quot;a&quot; &quot;xaxax&quot;       = &quot;xbxbx&quot;
sed (\ x -&gt; x ++ x) &quot;a&quot; &quot;xax&quot;     = &quot;xaax&quot;
sed undefined       &quot;[&quot; &quot;xxx&quot;     = &quot;xxx&quot;</pre></div></div><div class="top"><p class="src"><a name="v:sedExt" class="def">sedExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; s -&gt; s -&gt; s <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#sedExt" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:split" class="def">split</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; (s, s) <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#split" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:splitRE">splitRE</a></code></p><p>examples:</p><pre>split &quot;a*b&quot; &quot;abc&quot; = (&quot;ab&quot;,&quot;c&quot;)
split &quot;a*&quot;  &quot;bc&quot;  = (&quot;&quot;, &quot;bc&quot;)    -- &quot;a*&quot; matches &quot;&quot;
split &quot;a+&quot;  &quot;bc&quot;  = (&quot;&quot;, &quot;bc&quot;)    -- &quot;a+&quot; does not match, no split
split &quot;[&quot;   &quot;abc&quot; = (&quot;&quot;, &quot;abc&quot;)   -- &quot;[&quot;  syntax error, no split</pre></div></div><div class="top"><p class="src"><a name="v:splitExt" class="def">splitExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; (s, s) <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#splitExt" class="link">Source</a></p><div class="doc"><p>split with extended syntax</p></div></div><div class="top"><p class="src"><a name="v:splitSubex" class="def">splitSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; ([(s, s)], s) <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#splitSubex" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:splitSubex">splitSubex</a></code>, uses extended syntax</p><p>examples:</p><pre>splitSubex &quot;({1}a*)b&quot;  &quot;abc&quot; = ([(&quot;1&quot;,&quot;a&quot;)],&quot;c&quot;)
splitSubex &quot;({2}a*)&quot;   &quot;bc&quot;  = ([(&quot;2&quot;,&quot;&quot;)], &quot;bc&quot;)
splitSubex &quot;({1}a|b)+&quot; &quot;abc&quot; = ([(&quot;1&quot;,&quot;a&quot;),(&quot;1&quot;,&quot;b&quot;)],&quot;c&quot;)        -- subex 1 matches 2 times

splitSubex &quot;.*({x}a*)&quot; &quot;aa&quot;  = ([(&quot;x&quot;,&quot;&quot;),(&quot;x&quot;,&quot;a&quot;),(&quot;x&quot;,&quot;aa&quot;)],&quot;&quot;)
                                                                  -- nondeterminism: 3 matches for a*

splitSubex &quot;({1}do)|({2}[a-z]+)&quot; &quot;do you know&quot;
                               = ([(&quot;1&quot;,&quot;do&quot;),(&quot;2&quot;,&quot;do&quot;)],&quot; you know&quot;)
                                                                  -- nondeterminism: 2 matches for do

splitSubex &quot;({1}do){|}({2}[a-z]+)&quot; &quot;do you know&quot;
                               = ([(&quot;1&quot;,&quot;do&quot;)],&quot; you know&quot;)
                                                                  -- no nondeterminism with {|}: 1. match for do

splitSubex &quot;({1}a+)&quot;   &quot;bcd&quot; = ([], &quot;bcd&quot;)                        -- no match
splitSubex &quot;[&quot;         &quot;abc&quot; = ([], &quot;abc&quot;)                        -- syntax error</pre></div></div><div class="top"><p class="src"><a name="v:tokenize" class="def">tokenize</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenize" class="link">Source</a></p><div class="doc"><p>split a string into tokens (words) by giving a regular expression
 which all tokens must match.</p><p>Convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:tokenizeRE">tokenizeRE</a></code></p><p>This can be used for simple tokenizers.
 It is recommended to use regular expressions where the empty word does not match.
 Else there will appear a lot of probably useless empty tokens in the output.
 All none matching chars are discarded. If the given regex contains syntax errors,
 <code>Nothing</code> is returned</p><p>examples:</p><pre>tokenize &quot;a&quot; &quot;aabba&quot;      = [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
tokenize &quot;a*&quot; &quot;aaaba&quot;     = [&quot;aaa&quot;,&quot;a&quot;]
tokenize &quot;a*&quot; &quot;bbb&quot;       = [&quot;&quot;,&quot;&quot;,&quot;&quot;]
tokenize &quot;a+&quot; &quot;bbb&quot;       = []

tokenize &quot;a*b&quot; &quot;&quot;         = []
tokenize &quot;a*b&quot; &quot;abc&quot;      = [&quot;ab&quot;]
tokenize &quot;a*b&quot; &quot;abaab ab&quot; = [&quot;ab&quot;,&quot;aab&quot;,&quot;ab&quot;]

tokenize &quot;[a-z]{2,}|[0-9]{2,}|[0-9]+[.][0-9]+&quot; &quot;ab123 456.7abc&quot;
                          = [&quot;ab&quot;,&quot;123&quot;,&quot;456.7&quot;,&quot;abc&quot;]

tokenize &quot;[a-z]*|[0-9]{2,}|[0-9]+[.][0-9]+&quot; &quot;cab123 456.7abc&quot;
                          = [&quot;cab&quot;,&quot;123&quot;,&quot;456.7&quot;,&quot;abc&quot;]

tokenize &quot;[^ \t\n\r]*&quot; &quot;abc def\t\n\rxyz&quot;
                          = [&quot;abc&quot;,&quot;def&quot;,&quot;xyz&quot;]

tokenize &quot;.*&quot;   &quot;\nabc\n123\n\nxyz\n&quot;
                          = [&quot;&quot;,&quot;abc&quot;,&quot;123&quot;,&quot;&quot;,&quot;xyz&quot;]

tokenize &quot;.*&quot;             = lines

tokenize &quot;[^ \t\n\r]*&quot;    = words</pre></div></div><div class="top"><p class="src"><a name="v:tokenizeExt" class="def">tokenizeExt</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeExt" class="link">Source</a></p><div class="doc"><p>tokenize with extended syntax</p></div></div><div class="top"><p class="src"><a name="v:tokenize-39-" class="def">tokenize'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenize%27" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:tokenizeRE-39-">tokenizeRE'</a></code></p><p>When the regular expression parses as Zero, <code>[Left input]</code> is returned, that means no tokens are found</p></div></div><div class="top"><p class="src"><a name="v:tokenizeExt-39-" class="def">tokenizeExt'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeExt%27" class="link">Source</a></p></div><div class="top"><p class="src"><a name="v:tokenizeSubex" class="def">tokenizeSubex</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; s -&gt; s -&gt; [(s, s)] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeSubex" class="link">Source</a></p><div class="doc"><p>convenient function for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:tokenizeSubexRE">tokenizeSubexRE</a></code> a string</p><p>examples:</p><pre>tokenizeSubex &quot;({name}[a-z]+)|({num}[0-9]{2,})|({real}[0-9]+[.][0-9]+)&quot;
                &quot;cab123 456.7abc&quot;
                                 = [(&quot;name&quot;,&quot;cab&quot;)
                                   ,(&quot;num&quot;,&quot;123&quot;)
                                   ,(&quot;real&quot;,&quot;456.7&quot;)
                                   ,(&quot;name&quot;,&quot;abc&quot;)]

tokenizeSubex &quot;({real}({n}[0-9]+)([.]({f}[0-9]+))?)&quot;
                &quot;12.34&quot;          = [(&quot;real&quot;,&quot;12.34&quot;)
                                   ,(&quot;n&quot;,&quot;12&quot;)
                                   ,(&quot;f&quot;,&quot;34&quot;)]

tokenizeSubex &quot;({real}({n}[0-9]+)([.]({f}[0-9]+))?)&quot;
                 &quot;12 34&quot;         = [(&quot;real&quot;,&quot;12&quot;),(&quot;n&quot;,&quot;12&quot;)
                                   ,(&quot;real&quot;,&quot;34&quot;),(&quot;n&quot;,&quot;34&quot;)]

tokenizeSubex &quot;({real}({n}[0-9]+)(([.]({f}[0-9]+))|({f})))&quot;
                 &quot;12 34.56&quot;      = [(&quot;real&quot;,&quot;12&quot;),(&quot;n&quot;,&quot;12&quot;),(&quot;f&quot;,&quot;&quot;)
                                   ,(&quot;real&quot;,&quot;34.56&quot;),(&quot;n&quot;,&quot;34&quot;),(&quot;f&quot;,&quot;56&quot;)]</pre></div></div><div class="top"><p class="src"><a name="v:matchRE" class="def">matchRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a> <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#matchRE" class="link">Source</a></p><div class="doc"><p>match a string with a regular expression</p></div></div><div class="top"><p class="src"><a name="v:matchSubexRE" class="def">matchSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [(s, s)] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#matchSubexRE" class="link">Source</a></p><div class="doc"><p>match a string with a regular expression
 and extract subexpression matches</p></div></div><div class="top"><p class="src"><a name="v:sedRE" class="def">sedRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; (s -&gt; s) -&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; s <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#sedRE" class="link">Source</a></p><div class="doc"><p>sed like editing function</p><p>All matching tokens are edited by the 1. argument, the editing function,
 all other chars remain as they are</p></div></div><div class="top"><p class="src"><a name="v:splitRE" class="def">splitRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> (s, s) <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#splitRE" class="link">Source</a></p><div class="doc"><p>split a string by taking the longest prefix matching a regular expression</p><p><code>Nothing</code> is returned in case there is no matching prefix,
 else the pair of prefix and rest is returned</p></div></div><div class="top"><p class="src"><a name="v:splitSubexRE" class="def">splitSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; <a href="../base-4.8.2.0/Data-Maybe.html#t:Maybe">Maybe</a> ([(s, s)], s) <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#splitSubexRE" class="link">Source</a></p><div class="doc"><p>split a string by removing the longest prefix matching a regular expression
 and then return the list of subexpressions found in the matching part</p><p><code>Nothing</code> is returned in case of no matching prefix,
 else the list of pairs of labels and submatches and the
 rest is returned</p></div></div><div class="top"><p class="src"><a name="v:tokenizeRE" class="def">tokenizeRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeRE" class="link">Source</a></p><div class="doc"><p>The function, that does the real work for <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:tokenize">tokenize</a></code></p></div></div><div class="top"><p class="src"><a name="v:tokenizeRE-39-" class="def">tokenizeRE'</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [<a href="../base-4.8.2.0/Data-Either.html#t:Either">Either</a> s s] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeRE%27" class="link">Source</a></p><div class="doc"><p>split a string into tokens and delimierter by giving a regular expression
 which all tokens must match</p><p>This is a generalisation of the above <code><a href="Text-Regex-XMLSchema-Generic-Matching.html#v:tokenizeRE">tokenizeRE</a></code> functions.
 The none matching char sequences are marked with <code>Left</code>, the matching ones are marked with <code>Right</code></p><p>If the regular expression contains syntax errors <code>Nothing</code> is returned</p><p>The following Law holds:</p><pre>concat . map (either id id) . tokenizeRE' re == id</pre></div></div><div class="top"><p class="src"><a name="v:tokenizeSubexRE" class="def">tokenizeSubexRE</a> :: <a href="Text-Regex-XMLSchema-Generic-StringLike.html#t:StringLike">StringLike</a> s =&gt; <a href="Text-Regex-XMLSchema-Generic-Regex.html#t:GenRegex">GenRegex</a> s -&gt; s -&gt; [(s, s)] <a href="src/Text-Regex-XMLSchema-Generic-Matching.html#tokenizeSubexRE" class="link">Source</a></p><div class="doc"><p>split a string into tokens (pair of labels and words) by giving a regular expression
 containing labeled subexpressions.</p><p>This function should not be called with regular expressions
 without any labeled subexpressions. This does not make sense, because the result list
 will always be empty.</p><p>Result is the list of matching subexpressions
 This can be used for simple tokenizers.
 At least one char is consumed by parsing a token.
 The pairs in the result list contain the matching substrings.
 All none matching chars are discarded. If the given regex contains syntax errors,
 <code>Nothing</code> is returned</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>