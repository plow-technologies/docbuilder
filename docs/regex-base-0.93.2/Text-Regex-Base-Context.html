<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Text.Regex.Base.Context</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Text-Regex-Base-Context.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Text-Regex-Base-Context.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">regex-base-0.93.2: Replaces/Enhances Text.Regex</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(c) Chris Kuklewicz 2006</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>libraries@haskell.org, textregexlazy@personal.mightyreason.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable (MPTC+FD)</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Text.Regex.Base.Context</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This is a module of instances of <code><a href="Text-Regex-Base-RegexLike.html#t:RegexContext">RegexContext</a></code> (defined in
Text.Regex.Base.RegexLike).  Nothing else is exported.  This is
usually imported via the Text.Regex.Base convenience package which
itself is re-exported from newer Text.Regex.XXX modules provided by
the different regex-xxx backends.</p><p>These instances work for all the supported types and backends
interchangably.  These instances provide the different results that
can be gotten from a match or matchM operation (often via the <code>=~</code> and
<code>=~~</code> operators with combine <code>makeRegex</code> with <code>match</code> and <code>matchM</code>
respectively).  This module name is Context because they operators are
context dependent: use them in a context that expects an Int and you
get a count of matches, use them in a Bool context and get True if
there is a match, etc.</p><p><code>RegexContext a b c</code> takes a regular expression suppied in a type <code>a</code>
generated by <code>RegexMaker</code> and a target text supplied in type <code>b</code> to a
result type <code>c</code> using the <code><a href="Text-Regex-Base-RegexLike.html#v:match">match</a></code> class function.  The <code><a href="Text-Regex-Base-RegexLike.html#v:matchM">matchM</a></code> class
function works like <code><a href="Text-Regex-Base-RegexLike.html#v:match">match</a></code> unless there is no match found, in which
case it calls <code><a href="../base-4.8.2.0/Control-Monad.html#v:fail">fail</a></code> in the (arbitrary) monad context.</p><p>There are a few type synonyms from RegexLike that are used here:</p><pre>-- | 0 based index from start of source, or (-1) for unused
type MatchOffset = Int
-- | non-negative length of a match
type MatchLength = Int
type MatchArray = Array Int (MatchOffset, MatchLength)
type MatchText source = Array Int (source, (MatchOffset, MatchLength))
</pre><p>There are also a few newtypes that used to prevent any possible
overlap of types, which were not needed for GHC's late overlap
detection but are needed for use in Hugs.</p><pre>newtype AllSubmatches f b = AllSubmatches {getAllSubmatches :: (f b)}
newtype AllTextSubmatches f b = AllTextSubmatches {getAllTextSubmatches :: (f b)}
newtype AllMatches f b = AllMatches {getAllMatches :: (f b)}
newtype AllTextMatches f b = AllTextMatches {getAllTextMatches :: (f b) }
</pre><p>The newtypes' <code>f</code> parameters are the containers, usually <code>[]</code> or
<code>Array Int</code>, (where the arrays all have lower bound 0).</p><p>The two *Submatches newtypes return only information on the first
match.  The other two newtypes return information on all the
non-overlapping matches.  The two *Text* newtypes are used to mark
result types that contain the same type as the target text.</p><p>Where provided, noncaptured submatches will have a <code>MatchOffset</code> of
(-1) and non-negative otherwise.  The semantics of submatches depend
on the backend and its compile and execution options.  Where provided,
<code>MatchLength</code> will always be non-negative.  Arrays with no elements
are returned with bounds of (1,0).  Arrays with elements will have a
lower bound of 0.</p><p>XXX THIS HADDOCK DOCUMENTATION IS OUT OF DATE XXX</p><p>These are for finding the first match in the target text:</p><p><code> RegexContext a b Bool </code> :
  Whether there is any match or not.</p><p><code> RegexContext a b () </code> :
  Useful as a guard with <code>matchM</code> or <code>=~~</code> in a monad, since failure to match calls <code><a href="../base-4.8.2.0/Control-Monad.html#v:fail">fail</a></code>.</p><p><code> RegexContext a b b </code> :
  This returns the text of the whole match.
  It will return <code><a href="Text-Regex-Base-RegexLike.html#v:empty">empty</a></code> from the <code><a href="Text-Regex-Base-RegexLike.html#t:Extract">Extract</a></code> type class if there is no match.
  These are defined in each backend module, but documented here for convenience.</p><p><code> RegexContext a b (MatchOffset,MatchLength) </code> :
  This returns the initial index and length of the whole match.
  MatchLength will always be non-negative, and 0 for a failed match.</p><p><code> RegexContext a b (MatchResult b) </code> : The
  <code><a href="Text-Regex-Base-RegexLike.html#t:MatchResult">MatchResult</a></code> structure with details for the match.  This is the
  structure copied from the old <code>JRegex</code> pacakge.</p><p><code> RegexContext a b (b, b, b) </code> :
  The text before the match, the text of the match, the text after the match</p><p><code> RegexContext a b (b, MatchText b, b) </code> :
  The text before the match, the details of the match, and the text after the match</p><p><code> RegexContext a b (b, b, b, [b]) </code> : 
  The text before the match, the text of the match, the text after the
  match, and a list of the text of the 1st and higher sub-parts of the
  match.  This is the same return value as used in the old
  <code>Text.Regex</code> API.</p><p>Two containers of the submatch offset information:</p><p><code> RegexContext a b MatchArray </code> :
  Array of <code>(MatchOffset,MatchLength)</code> for all the sub matches.
  The whole match is at the intial 0th index.
  Noncaptured submatches will have a <code>MatchOffset</code> of (-1)
  The array will have no elements and bounds (1,0) if there is no match.</p><p><code> RegexContext a b (AllSubmatches [] (MatchOffset,MatchLength) </code> :
  List of <code>(MatchOffset,MatchLength)</code>
  The whole match is the first element, the rest are the submatches (if any) in order.
  The list is empty if there is no match.</p><p>Two containers of the submatch text and offset information:</p><pre> RegexContext a b (AllTextSubmatches (Array Int) (b, (MatchOffset, MatchLength)))</pre><pre> RegexContext a b (AllTextSubmatches [] (b, (MatchOffset, MatchLength)))</pre><p>Two containers of the submatch text information:</p><pre> RegexContext a b (AllTextSubmatches [] b)</pre><pre> RegexContext a b (AllTextSubmatches (Array Int) b)</pre><p>These instances are for all the matches (non-overlapping).  Note that
backends are supposed to supply <code><a href="Text-Regex-Base-RegexLike.html#t:RegexLike">RegexLike</a></code> instances for which the
default <code><a href="Text-Regex-Base-RegexLike.html#v:matchAll">matchAll</a></code> and <code><a href="Text-Regex-Base-RegexLike.html#v:matchAllText">matchAllText</a></code> stop searching after returning
any successful but empty match.</p><p><code> RegexContext a b Int </code> :
  The number of matches, non-negative.</p><p>Two containers for locations of all matches:</p><pre> RegexContext a b (AllMatches [] (MatchOffset, MatchLength))</pre><pre> RegexContext a b (AllMatches (Array Int) (MatchOffset,MatchLength))</pre><p>Two containers for the locations of all matches and their submatches:</p><p><code> RegexContext a b [MatchArray] </code> :</p><pre> RegexContext a b (AllMatches (Array Int) MatchArray)</pre><p>Two containers for the text and locations of all matches and their submatches:</p><pre> RegexContext a b [MatchText b]</pre><pre> RegexContext a b (AllTextMatches (Array Int) (MatchText b))</pre><p>Two containers for text of all matches:
<code> RegexContext a b (AllTextMatches [] b) </code></p><pre> RegexContext a b (AllTextMatches (Array Int) b)</pre><p>Four containers for text of all matches and their submatches:</p><pre> RegexContext a b [[b]]</pre><pre> RegexContext a b (AllTextMatches (Array Int) [b])</pre><pre> RegexContext a b (AllTextMatches [] (Array Int b))</pre><pre> RegexContext a b (AllTextMatches (Array Int) (Array Int b))</pre><p>Unused matches are <code><a href="Text-Regex-Base-RegexLike.html#v:empty">empty</a></code> (defined via <code><a href="Text-Regex-Base-RegexLike.html#t:Extract">Extract</a></code>)</p></div></div><div id="interface"></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>