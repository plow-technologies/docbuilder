-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Lens powered regular expression
--   
--   Lens powered regular expression
@package lens-regex
@version 0.1.0

module Text.Regex.Quote

-- | Generate compiled regular expression.
--   
--   This QuasiQuote is shorthand of <i>makeRegex with type
--   annotations</i>:
--   
--   <pre>
--   [r|hogehoge|] == (makeRegex ("hogehoge" :: String) :: Regex)
--   </pre>
--   
--   The <i>Regex</i> type signature in the above example, is the type
--   which is named as <i>Regex</i> in this translation unit. Therefore,
--   you can choose Regex type by changing imports.
--   
--   For example, the <i>exp</i> variable in the below example has the type
--   of Text.Regex.Posix.Regex:
--   
--   <pre>
--   import Text.Regex.Posix (Regex)
--   exp = [r|hoge|]
--   </pre>
--   
--   and, the <i>exp</i> variable in below example has the type of
--   Text.Regex.PCRE.Regex:
--   
--   <pre>
--   import Text.Regex.PCRE (Regex)
--   exp = [r|hoge|]
--   </pre>
r :: QuasiQuoter

module Text.Regex.Lens
data MatchPart text
MatchPart :: text -> [text] -> MatchPart text
[_matchedString] :: MatchPart text -> text
[_captures] :: MatchPart text -> [text]
matchedString :: Lens' (MatchPart text_adea) text_adea
captures :: Getter (MatchPart text_adea) [text_adea]

-- | An indexed Traversal for matched part with regexp.
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" ^? regex [r|b.*r|]
--   Just (MatchPart {_matchedString = "bar", _captures = []})
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" ^? regex [r|hoge|]
--   Nothing
--   </pre>
--   
--   You can access to the matched string by using <a>matchedString</a>:
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" ^? regex [r|b.*r|] . matchedString
--   Just "bar"
--   </pre>
--   
--   Multiple result:
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" ^.. regex [r|b[^ ]+|] . matchedString
--   ["bar","baz"]
--   </pre>
--   
--   Replace:
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" &amp; regex [r|b[^ ]+|] . matchedString .~ "nya"
--   "foo nya nya"
--   </pre>
--   
--   Indexing:
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" ^.. regex [r|b[^ ]+|] . index 1 . matchedString
--   ["baz"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo bar baz" &amp; regex [r|b[^ ]+|] . index 1 . matchedString .~ "nya"
--   "foo bar nya"
--   </pre>
--   
--   Captures:
--   
--   <pre>
--   &gt;&gt;&gt; "foo00 bar01 baz02" ^.. regex [r|([a-z]+)([0-9]+)|] . captures
--   [["foo","00"],["bar","01"],["baz","02"]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "foo00 bar01 baz02" ^.. regex [r|([a-z]+)([0-9]+)|] . captures . traversed . index 1
--   ["00","01","02"]
--   </pre>
--   
--   <i>Note</i>: This is <i>not</i> a legal Traversal, unless you are very
--   careful not to invalidate the predicate on the target. For example, if
--   you replace the matched part with a string which is not match with the
--   regex, the second <a>Traversal</a> law is violated.
--   
--   <pre>
--   let l = regex [r|t.*t|] . matchedString
--   <a>over</a> l (++ "peta") <a>.</a> <a>over</a> l (++ "nya") <a>/=</a> <a>over</a> l ((++ "peta") . (++ "nya"))
--   <a>over</a> l (++ "put") <a>.</a> <a>over</a> l (++ "hot") <a>==</a> <a>over</a> l ((++ "put") . (++ "hot"))
--   </pre>
regex :: (RegexLike regex text, Monoid text) => regex -> IndexedTraversal' Int text (MatchPart text)
regex' :: (RegexLike regex text, Monoid text) => regex -> Lens' text (RegexResult text)
matched :: (Indexable Int p, Applicative f) => p (MatchPart text) (f (MatchPart text)) -> RegexResult text -> f (RegexResult text)
matched' :: Traversal' (RegexResult text) (MatchPart text)
instance GHC.Show.Show text => GHC.Show.Show (Text.Regex.Lens.MatchPart text)
