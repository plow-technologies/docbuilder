<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Arrow.ArrowTree</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Arrow-ArrowTree.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Arrow-ArrowTree.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">hxt-9.3.1.15: A collection of tools for processing XML with Haskell.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Copyright (C) 2010 Uwe Schmidt</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Uwe Schmidt (uwe\@fh-wedel.de)</td></tr><tr><th>Stability</th><td>stable</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Arrow.ArrowTree</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>List arrows for tree processing.</p><p>Trees that implement the <a href="Data-Tree-Class.html">Data.Tree.Class</a> interface, can be processed
   with these arrows.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (<a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowPlus">ArrowPlus</a> a, <a href="Control-Arrow-ArrowIf.html#t:ArrowIf">ArrowIf</a> a) =&gt; <a href="#t:ArrowTree">ArrowTree</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:mkLeaf">mkLeaf</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; a c (t b)</li><li><a href="#v:mkTree">mkTree</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; [t b] -&gt; a c (t b)</li><li><a href="#v:getChildren">getChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b)</li><li><a href="#v:getNode">getNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) b</li><li><a href="#v:hasNode">hasNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; (b -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; a (t b) (t b)</li><li><a href="#v:setChildren">setChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; [t b] -&gt; a (t b) (t b)</li><li><a href="#v:setNode">setNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; a (t b) (t b)</li><li><a href="#v:changeChildren">changeChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; ([t b] -&gt; [t b]) -&gt; a (t b) (t b)</li><li><a href="#v:changeNode">changeNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; (b -&gt; b) -&gt; a (t b) (t b)</li><li><a href="#v:processChildren">processChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:replaceChildren">replaceChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:-47--62-">(/&gt;)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a b (t c) -&gt; a (t c) d -&gt; a b d</li><li><a href="#v:-47--47--62-">(//&gt;)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a b (t c) -&gt; a (t c) d -&gt; a b d</li><li><a href="#v:-60--47-">(&lt;/)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:deep">deep</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c</li><li><a href="#v:deepest">deepest</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c</li><li><a href="#v:multi">multi</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c</li><li><a href="#v:processBottomUp">processBottomUp</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:processTopDown">processTopDown</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:processBottomUpWhenNot">processBottomUpWhenNot</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:processTopDownUntil">processTopDownUntil</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:insertChildrenAt">insertChildrenAt</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:insertChildrenAfter">insertChildrenAfter</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b)</li><li><a href="#v:insertTreeTemplate">insertTreeTemplate</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; [<a href="Control-Arrow-ArrowIf.html#t:IfThen">IfThen</a> (a (t b) c) (a (t b) (t b))] -&gt; a (t b) (t b)</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:Tree">Tree</a> t</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowPlus">ArrowPlus</a> a, <a href="Control-Arrow-ArrowIf.html#t:ArrowIf">ArrowIf</a> a) =&gt; <a name="t:ArrowTree" class="def">ArrowTree</a> a <span class="keyword">where</span> <a href="src/Control-Arrow-ArrowTree.html#ArrowTree" class="link">Source</a></p><div class="doc"><p>The interface for tree arrows</p><p>all functions have default implementations</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:mkLeaf" class="def">mkLeaf</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; a c (t b) <a href="src/Control-Arrow-ArrowTree.html#mkLeaf" class="link">Source</a></p><div class="doc"><p>construct a leaf</p></div><p class="src"><a name="v:mkTree" class="def">mkTree</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; [t b] -&gt; a c (t b) <a href="src/Control-Arrow-ArrowTree.html#mkTree" class="link">Source</a></p><div class="doc"><p>construct an inner node</p></div><p class="src"><a name="v:getChildren" class="def">getChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#getChildren" class="link">Source</a></p><div class="doc"><p>select the children of the root of a tree</p></div><p class="src"><a name="v:getNode" class="def">getNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) b <a href="src/Control-Arrow-ArrowTree.html#getNode" class="link">Source</a></p><div class="doc"><p>select the node info of the root of a tree</p></div><p class="src"><a name="v:hasNode" class="def">hasNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; (b -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#hasNode" class="link">Source</a></p><div class="doc"><p>select the attribute of the root of a tree</p></div><p class="src"><a name="v:setChildren" class="def">setChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; [t b] -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#setChildren" class="link">Source</a></p><div class="doc"><p>substitute the children of the root of a tree</p></div><p class="src"><a name="v:setNode" class="def">setNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; b -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#setNode" class="link">Source</a></p><div class="doc"><p>substitute the attribute of the root of a tree</p></div><p class="src"><a name="v:changeChildren" class="def">changeChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; ([t b] -&gt; [t b]) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#changeChildren" class="link">Source</a></p><div class="doc"><p>edit the children of the root of a tree</p></div><p class="src"><a name="v:changeNode" class="def">changeNode</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; (b -&gt; b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#changeNode" class="link">Source</a></p><div class="doc"><p>edit the attribute of the root of a tree</p></div><p class="src"><a name="v:processChildren" class="def">processChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#processChildren" class="link">Source</a></p><div class="doc"><p>apply an arrow element wise to all children of the root of a tree
 collect these results and substitute the children with this result</p><p>example: <code> processChildren isText </code> deletes all subtrees, for which isText does not hold</p><p>example: <code> processChildren (none `when` isCmt) </code> removes all children, for which isCmt holds</p></div><p class="src"><a name="v:replaceChildren" class="def">replaceChildren</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#replaceChildren" class="link">Source</a></p><div class="doc"><p>similar to processChildren, but the new children are computed by processing
 the whole input tree</p><p>example: <code> replaceChildren (deep isText) </code> selects all subtrees for which isText holds
 and substitutes the children component of the root node with this list</p></div><p class="src"><a name="v:-47--62-" class="def">(/&gt;)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a b (t c) -&gt; a (t c) d -&gt; a b d <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowTree.html#%2F%3E" class="link">Source</a></p><div class="doc"><p>pronounced &quot;slash&quot;, meaning g inside f</p><p>defined as <code> f /&gt; g = f &gt;&gt;&gt; getChildren &gt;&gt;&gt; g </code></p><p>example: <code> hasName &quot;html&quot; /&gt; hasName &quot;body&quot; /&gt; hasName &quot;h1&quot; </code></p><p>This expression selects
 all &quot;h1&quot; elements in the &quot;body&quot; element of an &quot;html&quot; element, an expression, that
 corresponds 1-1 to the XPath selection path &quot;html/body/h1&quot;</p></div><p class="src"><a name="v:-47--47--62-" class="def">(//&gt;)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a b (t c) -&gt; a (t c) d -&gt; a b d <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowTree.html#%2F%2F%3E" class="link">Source</a></p><div class="doc"><p>pronounced &quot;double slash&quot;, meaning g arbitrarily deep inside f</p><p>defined as <code> f //&gt; g = f &gt;&gt;&gt; getChildren &gt;&gt;&gt; deep g </code></p><p>example: <code> hasName &quot;html&quot; //&gt; hasName &quot;table&quot; </code></p><p>This expression selects
 all top level &quot;table&quot; elements within an &quot;html&quot; element, an expression.
 Attantion: This does not correspond
 to the XPath selection path &quot;html//table&quot;. The latter on matches all table elements
 even nested ones, but <code>//&gt;</code> gives in many cases the appropriate functionality.</p></div><p class="src"><a name="v:-60--47-" class="def">(&lt;/)</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b) <span class="fixity">infixl 5</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowTree.html#%3C%2F" class="link">Source</a></p><div class="doc"><p>pronounced &quot;outside&quot; meaning f containing g</p><p>defined as <code> f &lt;/ g = f `containing` (getChildren &gt;&gt;&gt; g) </code></p></div><p class="src"><a name="v:deep" class="def">deep</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c <a href="src/Control-Arrow-ArrowTree.html#deep" class="link">Source</a></p><div class="doc"><p>recursively searches a whole tree for subtrees, for which a predicate holds.
 The search is performed top down. When a tree is found, this becomes an element of the result
 list. The tree found is not further examined for any subtress, for which the predicate also could hold.
 See <code><a href="Control-Arrow-ArrowTree.html#v:multi">multi</a></code> for this kind of search.</p><p>example: <code> deep isHtmlTable </code> selects all top level table elements in a document
 (with an appropriate definition for isHtmlTable) but no tables occuring within a table cell.</p></div><p class="src"><a name="v:deepest" class="def">deepest</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c <a href="src/Control-Arrow-ArrowTree.html#deepest" class="link">Source</a></p><div class="doc"><p>recursively searches a whole tree for subrees, for which a predicate holds.
 The search is performed bottom up.</p><p>example: <code> deepest isHtmlTable </code> selects all innermost table elements in a document
 but no table elements containing tables. See <code><a href="Control-Arrow-ArrowTree.html#v:deep">deep</a></code> and <code><a href="Control-Arrow-ArrowTree.html#v:multi">multi</a></code> for other search strategies.</p></div><p class="src"><a name="v:multi" class="def">multi</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) c -&gt; a (t b) c <a href="src/Control-Arrow-ArrowTree.html#multi" class="link">Source</a></p><div class="doc"><p>recursively searches a whole tree for subtrees, for which a predicate holds.
 The search is performed top down. All nodes of the tree are searched, even within the
 subtrees of trees for which the predicate holds.</p><p>example: <code> multi isHtmlTable </code> selects all table elements, even nested ones.</p></div><p class="src"><a name="v:processBottomUp" class="def">processBottomUp</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#processBottomUp" class="link">Source</a></p><div class="doc"><p>recursively transforms a whole tree by applying an arrow to all subtrees,
 this is done bottom up depth first, leaves first, root as last tree</p><p>example: <code> processBottomUp (getChildren `when` isHtmlFont) </code> removes all font tags in a HTML document, even nested ones
 (with an appropriate definition of isHtmlFont)</p></div><p class="src"><a name="v:processTopDown" class="def">processTopDown</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#processTopDown" class="link">Source</a></p><div class="doc"><p>similar to <code><a href="Control-Arrow-ArrowTree.html#v:processBottomUp">processBottomUp</a></code>, but recursively transforms a whole tree by applying an arrow to all subtrees
 with a top down depth first traversal strategie. In many cases <code><a href="Control-Arrow-ArrowTree.html#v:processBottomUp">processBottomUp</a></code> and <code><a href="Control-Arrow-ArrowTree.html#v:processTopDown">processTopDown</a></code>
 give same results.</p></div><p class="src"><a name="v:processBottomUpWhenNot" class="def">processBottomUpWhenNot</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#processBottomUpWhenNot" class="link">Source</a></p><div class="doc"><p>recursively transforms a whole tree by applying an arrow to all subtrees,
 but transformation stops when a predicte does not hold for a subtree,
 leaves are transformed first</p></div><p class="src"><a name="v:processTopDownUntil" class="def">processTopDownUntil</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#processTopDownUntil" class="link">Source</a></p><div class="doc"><p>recursively transforms a whole tree by applying an arrow to all subtrees,
 but transformation stops when a tree is successfully transformed.
 the transformation is done top down</p><p>example: <code> processTopDownUntil (isHtmlTable `guards` tranformTable) </code>
 transforms all top level table elements into something else, but inner tables remain unchanged</p></div><p class="src"><a name="v:insertChildrenAt" class="def">insertChildrenAt</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; <a href="../base-4.8.2.0/Data-Int.html#t:Int">Int</a> -&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#insertChildrenAt" class="link">Source</a></p><div class="doc"><p>computes a list of trees by applying an arrow to the input
 and inserts this list in front of index i in the list of children</p><p>example: <code> insertChildrenAt 0 (deep isCmt) </code> selects all subtrees for which isCmt holds
 and copies theses in front of the existing children</p></div><p class="src"><a name="v:insertChildrenAfter" class="def">insertChildrenAfter</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; a (t b) (t b) -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#insertChildrenAfter" class="link">Source</a></p><div class="doc"><p>similar to <code><a href="Control-Arrow-ArrowTree.html#v:insertChildrenAt">insertChildrenAt</a></code>, but the insertion position is searched with a predicate</p></div><p class="src"><a name="v:insertTreeTemplate" class="def">insertTreeTemplate</a> :: <a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> t =&gt; a (t b) (t b) -&gt; [<a href="Control-Arrow-ArrowIf.html#t:IfThen">IfThen</a> (a (t b) c) (a (t b) (t b))] -&gt; a (t b) (t b) <a href="src/Control-Arrow-ArrowTree.html#insertTreeTemplate" class="link">Source</a></p><div class="doc"><p>an arrow for inserting a whole subtree with some holes in it (a template)
 into a document. The holes can be filled with contents from the input.</p><p>Example</p><pre>insertTreeTemplateTest :: ArrowXml a =&gt; a b XmlTree
insertTreeTemplateTest
    = doc
      &gt;&gt;&gt;
      insertTreeTemplate template pattern
    where
    doc                                                                -- the input data
       = constA &quot;&lt;x&gt;&lt;y&gt;The Title&lt;/y&gt;&lt;z&gt;The content&lt;/z&gt;&lt;/x&gt;&quot;
         &gt;&gt;&gt; xread
    template                                                           -- the output template with 2 holes: xxx and yyy
       = constA &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;xxx&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;yyy&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;
         &gt;&gt;&gt; xread
    pattern
       = [ hasText (== &quot;xxx&quot;)                                          -- fill the xxx hole with the input contents from element &quot;x/y&quot;
           :-&gt; ( getChildren &gt;&gt;&gt; hasName &quot;y&quot; &gt;&gt;&gt; deep isText )

         , hasText (== &quot;yyy&quot;)                                          -- fill the yyy hole with the input contents from element &quot;x/z&quot;
           :-&gt; ( getChildren &gt;&gt;&gt; hasName &quot;z&quot; &gt;&gt;&gt; getChildren )
         ]</pre><p>computes the XML tree for the following document</p><pre>&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;The content&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&quot;</pre></div></div><div class="subs instances"><p id="control.i:ArrowTree" class="caption collapser" onclick="toggleSection('i:ArrowTree')">Instances</p><div id="section.i:ArrowTree" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:ArrowTree">ArrowTree</a> <a href="Control-Arrow-ListArrow.html#t:LA">LA</a></span> <a href="src/Control-Arrow-ArrowTree.html#line-114" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:ArrowTree">ArrowTree</a> <a href="Control-Arrow-IOListArrow.html#t:IOLA">IOLA</a></span> <a href="src/Control-Arrow-ArrowTree.html#line-141" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:ArrowTree">ArrowTree</a> (<a href="Control-Arrow-StateListArrow.html#t:SLA">SLA</a> s)</span> <a href="src/Control-Arrow-ArrowTree.html#line-173" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:ArrowTree">ArrowTree</a> (<a href="Control-Arrow-IOStateListArrow.html#t:IOSLA">IOSLA</a> s)</span> <a href="src/Control-Arrow-ArrowTree.html#line-219" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:Tree" class="def">Tree</a> t <a href="src/Data-Tree-Class.html#Tree" class="link">Source</a></p><div class="doc"><p>The interface for trees</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Data-Tree-Class.html#v:mkTree">mkTree</a>, <a href="Data-Tree-Class.html#v:getNode">getNode</a>, <a href="Data-Tree-Class.html#v:getChildren">getChildren</a>, <a href="Data-Tree-Class.html#v:changeNode">changeNode</a>, <a href="Data-Tree-Class.html#v:changeChildren">changeChildren</a>, <a href="Data-Tree-Class.html#v:foldTree">foldTree</a></p></div><div class="subs instances"><p id="control.i:Tree" class="caption collapser" onclick="toggleSection('i:Tree')">Instances</p><div id="section.i:Tree" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> <a href="Data-Tree-NTree-TypeDefs.html#t:NTree">NTree</a></span> <a href="src/Data-Tree-Class.html#line-113" class="link">Source</a></td><td class="doc"><p>Implementation of <a href="Data-Tree-Class.html">Data.Tree.Class</a> interface for rose trees</p></td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowTree.html#t:Tree">Tree</a> <a href="Data-Tree-NTree-Zipper-TypeDefs.html#t:NTZipper">NTZipper</a></span> <a href="src/Data-Tree-Class.html#line-191" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>