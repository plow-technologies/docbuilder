<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Arrow.ArrowList</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Arrow-ArrowList.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Arrow-ArrowList.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">hxt-9.3.1.15: A collection of tools for processing XML with Haskell.</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>Copyright (C) 2005 Uwe Schmidt</td></tr><tr><th>License</th><td>MIT</td></tr><tr><th>Maintainer</th><td>Uwe Schmidt (uwe\@fh-wedel.de)</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Arrow.ArrowList</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The list arrow class</p><p>This module defines the interface for list arrows.</p><p>A list arrow is a function, that gives a list of results
   for a given argument. A single element result represents a normal function.
   An empty list oven indicates, the function is undefined for the given argument.
   The empty list may also represent False, none empty lists True.
   A list with more than one element gives all results for a nondeterministic function.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">class</span> (<a href="../base-4.8.2.0/Control-Arrow.html#t:Arrow">Arrow</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowPlus">ArrowPlus</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowZero">ArrowZero</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowApply">ArrowApply</a> a) =&gt; <a href="#t:ArrowList">ArrowList</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:arr2">arr2</a> :: (b1 -&gt; b2 -&gt; c) -&gt; a (b1, b2) c</li><li><a href="#v:arr3">arr3</a> :: (b1 -&gt; b2 -&gt; b3 -&gt; c) -&gt; a (b1, (b2, b3)) c</li><li><a href="#v:arr4">arr4</a> :: (b1 -&gt; b2 -&gt; b3 -&gt; b4 -&gt; c) -&gt; a (b1, (b2, (b3, b4))) c</li><li><a href="#v:arr2A">arr2A</a> :: (b -&gt; a c d) -&gt; a (b, c) d</li><li><a href="#v:arrL">arrL</a> :: (b -&gt; [c]) -&gt; a b c</li><li><a href="#v:arr2L">arr2L</a> :: (b -&gt; c -&gt; [d]) -&gt; a (b, c) d</li><li><a href="#v:constA">constA</a> :: c -&gt; a b c</li><li><a href="#v:constL">constL</a> :: [c] -&gt; a b c</li><li><a href="#v:isA">isA</a> :: (b -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; a b b</li><li><a href="#v:-62--62-.">(&gt;&gt;.)</a> :: a b c -&gt; ([c] -&gt; [d]) -&gt; a b d</li><li><a href="#v:-62-.">(&gt;.)</a> :: a b c -&gt; ([c] -&gt; d) -&gt; a b d</li><li><a href="#v:listA">listA</a> :: a b c -&gt; a b [c]</li><li><a href="#v:unlistA">unlistA</a> :: a [b] b</li><li><a href="#v:this">this</a> :: a b b</li><li><a href="#v:none">none</a> :: a b c</li><li><a href="#v:withDefault">withDefault</a> :: a b c -&gt; c -&gt; a b c</li><li><a href="#v:single">single</a> :: a b c -&gt; a b c</li><li><a href="#v:applyA">applyA</a> :: a b (a b c) -&gt; a b c</li><li><a href="#v:-36--60-">($&lt;)</a> :: (c -&gt; a b d) -&gt; a b c -&gt; a b d</li><li><a href="#v:-36--60--60-">($&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; a b d) -&gt; a b (c1, c2) -&gt; a b d</li><li><a href="#v:-36--60--60--60-">($&lt;&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; c3 -&gt; a b d) -&gt; a b (c1, (c2, c3)) -&gt; a b d</li><li><a href="#v:-36--60--60--60--60-">($&lt;&lt;&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; a b d) -&gt; a b (c1, (c2, (c3, c4))) -&gt; a b d</li><li><a href="#v:-36--60--36-">($&lt;$)</a> :: (c -&gt; a b b) -&gt; a b c -&gt; a b b</li><li><a href="#v:mergeA">mergeA</a> :: (a (a1, b1) a1 -&gt; a (a1, b1) b1 -&gt; a (a1, b1) c) -&gt; a (a1, b1) c</li><li><a href="#v:perform">perform</a> :: a b c -&gt; a b b</li><li><a href="#v:catA">catA</a> :: [a b c] -&gt; a b c</li><li><a href="#v:seqA">seqA</a> :: [a b b] -&gt; a b b</li></ul></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">class</span> (<a href="../base-4.8.2.0/Control-Arrow.html#t:Arrow">Arrow</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowPlus">ArrowPlus</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowZero">ArrowZero</a> a, <a href="../base-4.8.2.0/Control-Arrow.html#t:ArrowApply">ArrowApply</a> a) =&gt; <a name="t:ArrowList" class="def">ArrowList</a> a <span class="keyword">where</span> <a href="src/Control-Arrow-ArrowList.html#ArrowList" class="link">Source</a></p><div class="doc"><p>The interface for list arrows</p><p>Only <code>mkA</code>, <code><a href="Control-Arrow-ArrowList.html#v:isA">isA</a></code> '(&gt;&gt;.)' don't have default implementations</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Control-Arrow-ArrowList.html#v:arrL">arrL</a>, <a href="Control-Arrow-ArrowList.html#v:isA">isA</a>, <a href="Control-Arrow-ArrowList.html#v:-62--62-.">(&gt;&gt;.)</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:arr2" class="def">arr2</a> :: (b1 -&gt; b2 -&gt; c) -&gt; a (b1, b2) c <a href="src/Control-Arrow-ArrowList.html#arr2" class="link">Source</a></p><div class="doc"><p>construction of a 2 argument arrow from a binary function
 |
 | example: <code> a1 &amp;&amp;&amp; a2 &gt;&gt;&gt; arr2 f </code></p></div><p class="src"><a name="v:arr3" class="def">arr3</a> :: (b1 -&gt; b2 -&gt; b3 -&gt; c) -&gt; a (b1, (b2, b3)) c <a href="src/Control-Arrow-ArrowList.html#arr3" class="link">Source</a></p><div class="doc"><p>construction of a 3 argument arrow from a 3-ary function
 |
 | example: <code> a1 &amp;&amp;&amp; a2 &amp;&amp;&amp; a3 &gt;&gt;&gt; arr3 f </code></p></div><p class="src"><a name="v:arr4" class="def">arr4</a> :: (b1 -&gt; b2 -&gt; b3 -&gt; b4 -&gt; c) -&gt; a (b1, (b2, (b3, b4))) c <a href="src/Control-Arrow-ArrowList.html#arr4" class="link">Source</a></p><div class="doc"><p>construction of a 4 argument arrow from a 4-ary function
 |
 | example: <code> a1 &amp;&amp;&amp; a2 &amp;&amp;&amp; a3 &amp;&amp;&amp; a4 &gt;&gt;&gt; arr4 f </code></p></div><p class="src"><a name="v:arr2A" class="def">arr2A</a> :: (b -&gt; a c d) -&gt; a (b, c) d <a href="src/Control-Arrow-ArrowList.html#arr2A" class="link">Source</a></p><div class="doc"><p>construction of a 2 argument arrow from a singe argument arrow</p></div><p class="src"><a name="v:arrL" class="def">arrL</a> :: (b -&gt; [c]) -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#arrL" class="link">Source</a></p><div class="doc"><p>constructor for a list arrow from a function with a list as result</p></div><p class="src"><a name="v:arr2L" class="def">arr2L</a> :: (b -&gt; c -&gt; [d]) -&gt; a (b, c) d <a href="src/Control-Arrow-ArrowList.html#arr2L" class="link">Source</a></p><div class="doc"><p>constructor for a list arrow with 2 arguments</p></div><p class="src"><a name="v:constA" class="def">constA</a> :: c -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#constA" class="link">Source</a></p><div class="doc"><p>constructor for a const arrow: <code> constA = arr . const </code></p></div><p class="src"><a name="v:constL" class="def">constL</a> :: [c] -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#constL" class="link">Source</a></p><div class="doc"><p>constructor for a const arrow: <code> constL = arrL . const </code></p></div><p class="src"><a name="v:isA" class="def">isA</a> :: (b -&gt; <a href="../base-4.8.2.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; a b b <a href="src/Control-Arrow-ArrowList.html#isA" class="link">Source</a></p><div class="doc"><p>builds an arrow from a predicate.
 If the predicate holds, the single list containing the input is returned, else the empty list</p></div><p class="src"><a name="v:-62--62-." class="def">(&gt;&gt;.)</a> :: a b c -&gt; ([c] -&gt; [d]) -&gt; a b d <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%3E%3E." class="link">Source</a></p><div class="doc"><p>combinator for converting the result of a list arrow into another list</p><p>example: <code> foo &gt;&gt;. reverse </code> reverses the the result of foo</p><p>example: <code> foo &gt;&gt;. take 1 </code> constructs a deterministic version of foo by deleting all further results</p></div><p class="src"><a name="v:-62-." class="def">(&gt;.)</a> :: a b c -&gt; ([c] -&gt; d) -&gt; a b d <span class="fixity">infixl 8</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%3E." class="link">Source</a></p><div class="doc"><p>combinator for converting the result of an arrow into a single element result</p></div><p class="src"><a name="v:listA" class="def">listA</a> :: a b c -&gt; a b [c] <a href="src/Control-Arrow-ArrowList.html#listA" class="link">Source</a></p><div class="doc"><p>combinator for converting an arrow into a determinstic version with all results collected in a single element list</p><pre> listA af = af &gt;&gt;. (:[])</pre><p>this is useful when the list of results computed by an arrow must be manipulated (e.g. sorted)</p><p>example for sorting the results of a filter</p><pre>collectAndSort         :: a b c -&gt; a b c

collectAndSort collect = listA collect &gt;&gt;&gt; arrL sort</pre></div><p class="src"><a name="v:unlistA" class="def">unlistA</a> :: a [b] b <a href="src/Control-Arrow-ArrowList.html#unlistA" class="link">Source</a></p><div class="doc"><p>the inverse of <code><a href="Control-Arrow-ArrowList.html#v:listA">listA</a></code></p><pre> listA af &gt;&gt;&gt; unlistA = af</pre><p>unlistA is defined as <code> arrL id </code></p></div><p class="src"><a name="v:this" class="def">this</a> :: a b b <a href="src/Control-Arrow-ArrowList.html#this" class="link">Source</a></p><div class="doc"><p>the identity arrow, alias for returnA</p></div><p class="src"><a name="v:none" class="def">none</a> :: a b c <a href="src/Control-Arrow-ArrowList.html#none" class="link">Source</a></p><div class="doc"><p>the zero arrow, alias for zeroArrow</p></div><p class="src"><a name="v:withDefault" class="def">withDefault</a> :: a b c -&gt; c -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#withDefault" class="link">Source</a></p><div class="doc"><p>converts an arrow, that may fail, into an arrow that always succeeds</p><p>example: <code> withDefault none &quot;abc&quot; </code> is equivalent to <code> constA &quot;abc&quot; </code></p></div><p class="src"><a name="v:single" class="def">single</a> :: a b c -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#single" class="link">Source</a></p><div class="doc"><p>makes a list arrow deterministic, the number of results is at most 1</p><p>definition</p><pre>single f = f &gt;&gt;. take 1</pre><p>examples with strings:</p><pre>runLA ( single none ) &quot;x&quot; == []
runLA ( single this ) &quot;x&quot; == [&quot;x&quot;]
runLA ( single
        (constA &quot;y&quot;
         &lt;+&gt; this ) ) &quot;x&quot; == [&quot;y&quot;]</pre></div><p class="src"><a name="v:applyA" class="def">applyA</a> :: a b (a b c) -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#applyA" class="link">Source</a></p><div class="doc"><p>compute an arrow from the input and apply the arrow to this input</p><p>definition: <code> (f &amp;&amp;&amp; this) &gt;&gt;&gt; app </code></p><p>in a point free style, there is no way to use an argument in 2 places,
 this is a combinator for simulating this. first the argument is used to compute an arrow,
 then this new arrow is applied to the input</p><p>applyA coresponds to: <code> apply f x = let g = f x in g x </code></p><p>see also: <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60-">$&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60--60-">$&lt;&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60--60--60-">$&lt;&lt;&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--36-">$&lt;$</a></code></p></div><p class="src"><a name="v:-36--60-" class="def">($&lt;)</a> :: (c -&gt; a b d) -&gt; a b c -&gt; a b d <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%24%3C" class="link">Source</a></p><div class="doc"><p>compute the parameter for an arrow with extra parameters from the input
 and apply the arrow for all parameter values to the input</p><p>a kind of &quot;function call&quot; for arrows, useful for joining arrows</p><pre>infixl 2 ($&lt;)</pre><p>definition:</p><pre>g $&lt; f = applyA (f &gt;&gt;&gt; arr g)</pre><p>if <code>f</code> fails, the whole arrow fails, e.g. <code> g $&lt; none == none </code></p><p>if <code>f</code> computes n values and <code>g</code> is deterministic, the whole arrow computes n values</p><p>examples with simple list arrows with strings</p><pre>prefixString   :: String -&gt; a String String
prefixString s =  arr (s++)

runLA ( prefixString $&lt; none           ) &quot;x&quot; == []
runLA ( prefixString $&lt; constA &quot;y&quot;     ) &quot;x&quot; == [&quot;yx&quot;]
runLA ( prefixString $&lt; this           ) &quot;x&quot; == [&quot;xx&quot;]
runLA ( prefixString $&lt; constA &quot;y&quot;
                        &lt;+&gt; constA &quot;z&quot; ) &quot;x&quot; == [&quot;yx&quot;,&quot;zx&quot;]
runLA ( prefixString $&lt; constA &quot;y&quot;
                        &lt;+&gt; this
                        &lt;+&gt; constA &quot;z&quot; ) &quot;x&quot; == [&quot;yx&quot;,&quot;xx&quot;,&quot;zx&quot;]</pre><p>see also: <code><a href="Control-Arrow-ArrowList.html#v:applyA">applyA</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60-">$&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60--60-">$&lt;&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--60--60--60-">$&lt;&lt;&lt;&lt;</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60--36-">$&lt;$</a></code></p></div><p class="src"><a name="v:-36--60--60-" class="def">($&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; a b d) -&gt; a b (c1, c2) -&gt; a b d <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%24%3C%3C" class="link">Source</a></p><div class="doc"><p>binary version of <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code></p><p>example with simple list arrows with strings</p><pre>infixString    :: String -&gt; String -&gt; a String String
infixString s1 s2
               = arr (\ s -&gt; s1 ++ s ++ s2)

runLA ( infixString $&lt;&lt; constA &quot;y&quot; &amp;&amp;&amp; constA &quot;z&quot; ) &quot;x&quot; = [&quot;yxz&quot;]
runLA ( infixString $&lt;&lt; this &amp;&amp;&amp; this             ) &quot;x&quot; = [&quot;xxx&quot;]
runLA ( infixString $&lt;&lt; constA &quot;y&quot;
                        &amp;&amp;&amp; (constA &quot;z&quot; &lt;+&gt; this) ) &quot;x&quot; = [&quot;yxz&quot;, &quot;yxx&quot;]</pre></div><p class="src"><a name="v:-36--60--60--60-" class="def">($&lt;&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; c3 -&gt; a b d) -&gt; a b (c1, (c2, c3)) -&gt; a b d <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%24%3C%3C%3C" class="link">Source</a></p><div class="doc"><p>version of <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code> for arrows with 3 extra parameters</p><p>typical usage</p><pre>f $&lt;&lt;&lt; g1 &amp;&amp;&amp; g2 &amp;&amp;&amp; g3</pre></div><p class="src"><a name="v:-36--60--60--60--60-" class="def">($&lt;&lt;&lt;&lt;)</a> :: (c1 -&gt; c2 -&gt; c3 -&gt; c4 -&gt; a b d) -&gt; a b (c1, (c2, (c3, c4))) -&gt; a b d <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%24%3C%3C%3C%3C" class="link">Source</a></p><div class="doc"><p>version of <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code> for arrows with 4 extra parameters</p><p>typical usage</p><pre>f $&lt;&lt;&lt;&lt; g1 &amp;&amp;&amp; g2 &amp;&amp;&amp; g3 &amp;&amp;&amp; g4</pre></div><p class="src"><a name="v:-36--60--36-" class="def">($&lt;$)</a> :: (c -&gt; a b b) -&gt; a b c -&gt; a b b <span class="fixity">infixl 2</span><span class="rightedge"></span> <a href="src/Control-Arrow-ArrowList.html#%24%3C%24" class="link">Source</a></p><div class="doc"><p>compute the parameter for an arrow <code>f</code> with an extra parameter by an arrow <code>g</code>
 and apply all the results from <code>g</code> sequentially to the input</p><pre>infixl 2 ($&lt;$)</pre><p>typical usage:</p><pre>g :: a b c
g = ...

f :: c -&gt; a b b
f x = ... x ...

f $&lt;$ g</pre><p><code>f</code> computes the extra parameters for <code>g</code> from the input of type <code>b</code> and <code>g</code> is applied with this
 parameter to the input. This allows programming in a point wise style in <code>g</code>, which becomes
 neccessary, when a value is needed more than once.</p><p>this combinator is useful, when transforming a single value (document) step by step,
 with <code>g</code> for collecting the data for all steps, and <code>f</code> for transforming the input step by step</p><p>if <code>g</code> is deterministic (computes exactly one result),
 <code> g $&lt;$ f == g $&lt; f </code> holds</p><p>if <code>g</code> fails, <code> f $&lt;$ g == this </code></p><p>if <code>g</code> computes more than one result, <code>f</code> is applied sequentially to the input for every result from <code>g</code></p><p>examples with simple list arrows with strings</p><pre>prefixString   :: String -&gt; a String String
prefixString s =  arr (s++)

runLA ( prefixString $&lt;$ none                      ) &quot;x&quot; == [&quot;x&quot;]
runLA ( prefixString $&lt;$ constA &quot;y&quot;                ) &quot;x&quot; == [&quot;yx&quot;]
runLA ( prefixString $&lt;$ constA &quot;y&quot; &lt;+&gt; constA &quot;z&quot; ) &quot;x&quot; == [&quot;zyx&quot;]
runLA ( prefixString $&lt;$ constA &quot;y&quot; &lt;+&gt; this
                         &lt;+&gt; constA &quot;z&quot;            ) &quot;x&quot; == [&quot;zxyx&quot;]</pre><p>example with two extra parameter</p><pre>g1 :: a b c1
g2 :: a b c2

f          :: (c1, c2) -&gt; a b b
f (x1, x2) =  ... x1 ... x2 ...

f $&lt;$ g1 &amp;&amp;&amp; g2</pre><p>see also: <code><a href="Control-Arrow-ArrowList.html#v:applyA">applyA</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code></p></div><p class="src"><a name="v:mergeA" class="def">mergeA</a> :: (a (a1, b1) a1 -&gt; a (a1, b1) b1 -&gt; a (a1, b1) c) -&gt; a (a1, b1) c <a href="src/Control-Arrow-ArrowList.html#mergeA" class="link">Source</a></p><div class="doc"><p>merge the result pairs of an arrow with type <code>a a1 (b1, b2)</code>
 by combining the tuple components with the <code>op</code> arrow</p><p>examples with simple list arrows working on strings and XmlTrees</p><pre>    a1 :: a String (XmlTree, XmlTree)
    a1 = selem &quot;foo&quot; [this &gt;&gt;&gt; mkText]
         &amp;&amp;&amp;
         selem &quot;bar&quot; [arr (++&quot;0&quot;) &gt;&gt;&gt; mkText]

    runLA (a1 &gt;&gt;&gt; mergeA (&lt;+&gt;) &gt;&gt;&gt; xshow this) &quot;42&quot; == [&quot;&lt;foo&gt;42&lt;/foo&gt;&quot;,&quot;&lt;bar&gt;420&lt;/bar&gt;&quot;]
    runLA (a1 &gt;&gt;&gt; mergeA (+=)  &gt;&gt;&gt; xshow this) &quot;42&quot; == [&quot;&lt;foo&gt;42&lt;bar&gt;420&lt;/bar&gt;&lt;/foo&gt;&quot;]</pre><p>see also: <code><a href="Control-Arrow-ArrowList.html#v:applyA">applyA</a></code>, <code><a href="Control-Arrow-ArrowList.html#v:-36--60-">$&lt;</a></code> and <code>+=</code> in class <code><a href="Text-XML-HXT-Arrow.html#v:ArrowXml">ArrowXml</a></code></p></div><p class="src"><a name="v:perform" class="def">perform</a> :: a b c -&gt; a b b <a href="src/Control-Arrow-ArrowList.html#perform" class="link">Source</a></p><div class="doc"><p>useful only for arrows with side effects: perform applies an arrow to the input
 ignores the result and returns the input</p><p>example: <code> ... &gt;&gt;&gt; perform someTraceArrow &gt;&gt;&gt; ... </code></p></div><p class="src"><a name="v:catA" class="def">catA</a> :: [a b c] -&gt; a b c <a href="src/Control-Arrow-ArrowList.html#catA" class="link">Source</a></p><div class="doc"><p>generalization of arrow combinator <code><a href="../base-4.8.2.0/Control-Arrow.html#v:-60--43--62-">&lt;+&gt;</a></code></p><p>definition: <code> catA = foldl (&lt;+&gt;) none </code></p></div><p class="src"><a name="v:seqA" class="def">seqA</a> :: [a b b] -&gt; a b b <a href="src/Control-Arrow-ArrowList.html#seqA" class="link">Source</a></p><div class="doc"><p>generalization of arrow combinator <code><a href="../base-4.8.2.0/Control-Category.html#v:-62--62--62-">&gt;&gt;&gt;</a></code></p><p>definition: <code> seqA = foldl (&gt;&gt;&gt;) this </code></p></div></div><div class="subs instances"><p id="control.i:ArrowList" class="caption collapser" onclick="toggleSection('i:ArrowList')">Instances</p><div id="section.i:ArrowList" class="show"><table><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowList.html#t:ArrowList">ArrowList</a> <a href="Control-Arrow-ListArrow.html#t:LA">LA</a></span> <a href="src/Control-Arrow-ArrowList.html#line-82" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowList.html#t:ArrowList">ArrowList</a> <a href="Control-Arrow-IOListArrow.html#t:IOLA">IOLA</a></span> <a href="src/Control-Arrow-ArrowList.html#line-101" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowList.html#t:ArrowList">ArrowList</a> (<a href="Control-Arrow-StateListArrow.html#t:SLA">SLA</a> s)</span> <a href="src/Control-Arrow-ArrowList.html#line-128" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src clearfix"><span class="inst-left"><a href="Control-Arrow-ArrowList.html#t:ArrowList">ArrowList</a> (<a href="Control-Arrow-IOStateListArrow.html#t:IOSLA">IOSLA</a> s)</span> <a href="src/Control-Arrow-ArrowList.html#line-125" class="link">Source</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.1</p></div></body></html>